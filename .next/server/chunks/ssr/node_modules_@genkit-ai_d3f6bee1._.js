module.exports = {

"[project]/node_modules/@genkit-ai/core/lib/__codegen/version.js [app-rsc] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all)=>{
    for(var name in all)__defProp(target, name, {
        get: all[name],
        enumerable: true
    });
};
var __copyProps = (to, from, except, desc)=>{
    if (from && typeof from === "object" || typeof from === "function") {
        for (let key of __getOwnPropNames(from))if (!__hasOwnProp.call(to, key) && key !== except) __defProp(to, key, {
            get: ()=>from[key],
            enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable
        });
    }
    return to;
};
var __toCommonJS = (mod)=>__copyProps(__defProp({}, "__esModule", {
        value: true
    }), mod);
var version_exports = {};
__export(version_exports, {
    version: ()=>version
});
module.exports = __toCommonJS(version_exports);
const version = "1.1.0";
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
    version
}); //# sourceMappingURL=version.js.map
}}),
"[project]/node_modules/@genkit-ai/core/lib/async.js [app-rsc] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all)=>{
    for(var name in all)__defProp(target, name, {
        get: all[name],
        enumerable: true
    });
};
var __copyProps = (to, from, except, desc)=>{
    if (from && typeof from === "object" || typeof from === "function") {
        for (let key of __getOwnPropNames(from))if (!__hasOwnProp.call(to, key) && key !== except) __defProp(to, key, {
            get: ()=>from[key],
            enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable
        });
    }
    return to;
};
var __toCommonJS = (mod)=>__copyProps(__defProp({}, "__esModule", {
        value: true
    }), mod);
var async_exports = {};
__export(async_exports, {
    Channel: ()=>Channel,
    LazyPromise: ()=>LazyPromise,
    lazy: ()=>lazy
});
module.exports = __toCommonJS(async_exports);
function createTask() {
    let resolve, reject;
    let promise = new Promise((res, rej)=>([resolve, reject] = [
            res,
            rej
        ]));
    return {
        resolve,
        reject,
        promise
    };
}
class Channel {
    ready = createTask();
    buffer = [];
    err = null;
    send(value) {
        this.buffer.push(value);
        this.ready.resolve();
    }
    close() {
        this.buffer.push(null);
        this.ready.resolve();
    }
    error(err) {
        this.err = err;
        this.ready.reject(err);
    }
    [Symbol.asyncIterator]() {
        return {
            next: async ()=>{
                if (this.err) {
                    throw this.err;
                }
                if (!this.buffer.length) {
                    await this.ready.promise;
                }
                const value = this.buffer.shift();
                if (!this.buffer.length) {
                    this.ready = createTask();
                }
                return {
                    value,
                    done: !value
                };
            }
        };
    }
}
class LazyPromise {
    executor;
    promise;
    constructor(executor){
        this.executor = executor;
    }
    then(onfulfilled, onrejected) {
        this.promise ??= new Promise(this.executor);
        return this.promise.then(onfulfilled, onrejected);
    }
}
function lazy(fn) {
    return new LazyPromise((resolve, reject)=>{
        try {
            resolve(fn());
        } catch (e) {
            reject(e);
        }
    });
}
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
    Channel,
    LazyPromise,
    lazy
}); //# sourceMappingURL=async.js.map
}}),
"[project]/node_modules/@genkit-ai/core/lib/statusTypes.js [app-rsc] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all)=>{
    for(var name in all)__defProp(target, name, {
        get: all[name],
        enumerable: true
    });
};
var __copyProps = (to, from, except, desc)=>{
    if (from && typeof from === "object" || typeof from === "function") {
        for (let key of __getOwnPropNames(from))if (!__hasOwnProp.call(to, key) && key !== except) __defProp(to, key, {
            get: ()=>from[key],
            enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable
        });
    }
    return to;
};
var __toESM = (mod, isNodeMode, target)=>(target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(// If the importer is in node compatibility mode or this is not an ESM
    // file that has been converted to a CommonJS file using a Babel-
    // compatible transform (i.e. "__esModule" has not been set), then set
    // "default" to the CommonJS "module.exports" for node compatibility.
    isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", {
        value: mod,
        enumerable: true
    }) : target, mod));
var __toCommonJS = (mod)=>__copyProps(__defProp({}, "__esModule", {
        value: true
    }), mod);
var statusTypes_exports = {};
__export(statusTypes_exports, {
    StatusCodes: ()=>StatusCodes,
    StatusNameSchema: ()=>StatusNameSchema,
    StatusSchema: ()=>StatusSchema,
    httpStatusCode: ()=>httpStatusCode
});
module.exports = __toCommonJS(statusTypes_exports);
var z = __toESM(__turbopack_context__.r("[project]/node_modules/zod/lib/index.js [app-rsc] (ecmascript)"));
var StatusCodes = /* @__PURE__ */ ((StatusCodes2)=>{
    StatusCodes2[StatusCodes2["OK"] = 0] = "OK";
    StatusCodes2[StatusCodes2["CANCELLED"] = 1] = "CANCELLED";
    StatusCodes2[StatusCodes2["UNKNOWN"] = 2] = "UNKNOWN";
    StatusCodes2[StatusCodes2["INVALID_ARGUMENT"] = 3] = "INVALID_ARGUMENT";
    StatusCodes2[StatusCodes2["DEADLINE_EXCEEDED"] = 4] = "DEADLINE_EXCEEDED";
    StatusCodes2[StatusCodes2["NOT_FOUND"] = 5] = "NOT_FOUND";
    StatusCodes2[StatusCodes2["ALREADY_EXISTS"] = 6] = "ALREADY_EXISTS";
    StatusCodes2[StatusCodes2["PERMISSION_DENIED"] = 7] = "PERMISSION_DENIED";
    StatusCodes2[StatusCodes2["UNAUTHENTICATED"] = 16] = "UNAUTHENTICATED";
    StatusCodes2[StatusCodes2["RESOURCE_EXHAUSTED"] = 8] = "RESOURCE_EXHAUSTED";
    StatusCodes2[StatusCodes2["FAILED_PRECONDITION"] = 9] = "FAILED_PRECONDITION";
    StatusCodes2[StatusCodes2["ABORTED"] = 10] = "ABORTED";
    StatusCodes2[StatusCodes2["OUT_OF_RANGE"] = 11] = "OUT_OF_RANGE";
    StatusCodes2[StatusCodes2["UNIMPLEMENTED"] = 12] = "UNIMPLEMENTED";
    StatusCodes2[StatusCodes2["INTERNAL"] = 13] = "INTERNAL";
    StatusCodes2[StatusCodes2["UNAVAILABLE"] = 14] = "UNAVAILABLE";
    StatusCodes2[StatusCodes2["DATA_LOSS"] = 15] = "DATA_LOSS";
    return StatusCodes2;
})(StatusCodes || {});
const StatusNameSchema = z.enum([
    "OK",
    "CANCELLED",
    "UNKNOWN",
    "INVALID_ARGUMENT",
    "DEADLINE_EXCEEDED",
    "NOT_FOUND",
    "ALREADY_EXISTS",
    "PERMISSION_DENIED",
    "UNAUTHENTICATED",
    "RESOURCE_EXHAUSTED",
    "FAILED_PRECONDITION",
    "ABORTED",
    "OUT_OF_RANGE",
    "UNIMPLEMENTED",
    "INTERNAL",
    "UNAVAILABLE",
    "DATA_LOSS"
]);
const statusCodeMap = {
    OK: 200,
    CANCELLED: 499,
    UNKNOWN: 500,
    INVALID_ARGUMENT: 400,
    DEADLINE_EXCEEDED: 504,
    NOT_FOUND: 404,
    ALREADY_EXISTS: 409,
    PERMISSION_DENIED: 403,
    UNAUTHENTICATED: 401,
    RESOURCE_EXHAUSTED: 429,
    FAILED_PRECONDITION: 400,
    ABORTED: 409,
    OUT_OF_RANGE: 400,
    UNIMPLEMENTED: 501,
    INTERNAL: 500,
    UNAVAILABLE: 503,
    DATA_LOSS: 500
};
function httpStatusCode(status) {
    if (!(status in statusCodeMap)) {
        throw new Error(`Invalid status code ${status}`);
    }
    return statusCodeMap[status];
}
const StatusCodesSchema = z.nativeEnum(StatusCodes);
const StatusSchema = z.object({
    code: StatusCodesSchema,
    message: z.string(),
    details: z.any().optional()
});
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
    StatusCodes,
    StatusNameSchema,
    StatusSchema,
    httpStatusCode
}); //# sourceMappingURL=statusTypes.js.map
}}),
"[project]/node_modules/@genkit-ai/core/lib/error.js [app-rsc] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all)=>{
    for(var name in all)__defProp(target, name, {
        get: all[name],
        enumerable: true
    });
};
var __copyProps = (to, from, except, desc)=>{
    if (from && typeof from === "object" || typeof from === "function") {
        for (let key of __getOwnPropNames(from))if (!__hasOwnProp.call(to, key) && key !== except) __defProp(to, key, {
            get: ()=>from[key],
            enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable
        });
    }
    return to;
};
var __toCommonJS = (mod)=>__copyProps(__defProp({}, "__esModule", {
        value: true
    }), mod);
var error_exports = {};
__export(error_exports, {
    GenkitError: ()=>GenkitError,
    UnstableApiError: ()=>UnstableApiError,
    UserFacingError: ()=>UserFacingError,
    assertUnstable: ()=>assertUnstable,
    getCallableJSON: ()=>getCallableJSON,
    getErrorMessage: ()=>getErrorMessage,
    getErrorStack: ()=>getErrorStack,
    getHttpStatus: ()=>getHttpStatus
});
module.exports = __toCommonJS(error_exports);
var import_statusTypes = __turbopack_context__.r("[project]/node_modules/@genkit-ai/core/lib/statusTypes.js [app-rsc] (ecmascript)");
class GenkitError extends Error {
    source;
    status;
    detail;
    code;
    // For easy printing, we wrap the error with information like the source
    // and status, but that's redundant with JSON.
    originalMessage;
    constructor({ status, message, detail, source }){
        super(`${source ? `${source}: ` : ""}${status}: ${message}`);
        this.originalMessage = message;
        this.code = (0, import_statusTypes.httpStatusCode)(status);
        this.status = status;
        this.detail = detail;
        this.name = "GenkitError";
    }
    /**
   * Returns a JSON-serializable representation of this object.
   */ toJSON() {
        return {
            // This error type is used by 3P authors with the field "detail",
            // but the actual Callable protocol value is "details"
            ...this.detail === void 0 ? {} : {
                details: this.detail
            },
            status: this.status,
            message: this.originalMessage
        };
    }
}
class UnstableApiError extends GenkitError {
    constructor(level, message){
        super({
            status: "FAILED_PRECONDITION",
            message: `${message ? message + " " : ""}This API requires '${level}' stability level.

To use this feature, initialize Genkit using \`import {genkit} from "genkit/${level}"\`.`
        });
        this.name = "UnstableApiError";
    }
}
function assertUnstable(registry, level, message) {
    if (level === "beta" && registry.apiStability === "stable") {
        throw new UnstableApiError(level, message);
    }
}
class UserFacingError extends GenkitError {
    constructor(status, message, details){
        super({
            status,
            detail: details,
            message
        });
        super.name = "UserFacingError";
    }
}
function getHttpStatus(e) {
    if (e instanceof GenkitError) {
        return e.code;
    }
    return 500;
}
function getCallableJSON(e) {
    if (e instanceof GenkitError) {
        return e.toJSON();
    }
    return {
        message: "Internal Error",
        status: "INTERNAL"
    };
}
function getErrorMessage(e) {
    if (e instanceof Error) {
        return e.message;
    }
    return `${e}`;
}
function getErrorStack(e) {
    if (e instanceof Error) {
        return e.stack;
    }
    return void 0;
}
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
    GenkitError,
    UnstableApiError,
    UserFacingError,
    assertUnstable,
    getCallableJSON,
    getErrorMessage,
    getErrorStack,
    getHttpStatus
}); //# sourceMappingURL=error.js.map
}}),
"[project]/node_modules/@genkit-ai/core/lib/context.js [app-rsc] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all)=>{
    for(var name in all)__defProp(target, name, {
        get: all[name],
        enumerable: true
    });
};
var __copyProps = (to, from, except, desc)=>{
    if (from && typeof from === "object" || typeof from === "function") {
        for (let key of __getOwnPropNames(from))if (!__hasOwnProp.call(to, key) && key !== except) __defProp(to, key, {
            get: ()=>from[key],
            enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable
        });
    }
    return to;
};
var __toCommonJS = (mod)=>__copyProps(__defProp({}, "__esModule", {
        value: true
    }), mod);
var context_exports = {};
__export(context_exports, {
    apiKey: ()=>apiKey,
    getContext: ()=>getContext,
    runWithContext: ()=>runWithContext
});
module.exports = __toCommonJS(context_exports);
var import_action = __turbopack_context__.r("[project]/node_modules/@genkit-ai/core/lib/action.js [app-rsc] (ecmascript)");
var import_error = __turbopack_context__.r("[project]/node_modules/@genkit-ai/core/lib/error.js [app-rsc] (ecmascript)");
const contextAlsKey = "core.auth.context";
function runWithContext(registry, context, fn) {
    if (context === void 0) {
        return fn();
    }
    return registry.asyncStore.run(contextAlsKey, context, ()=>(0, import_action.runInActionRuntimeContext)(registry, fn));
}
function getContext(registry) {
    if (registry.registry) {
        registry = registry.registry;
    }
    registry = registry;
    return registry.asyncStore.getStore(contextAlsKey);
}
function apiKey(valueOrPolicy) {
    return async function(request) {
        const context = {
            auth: {
                apiKey: request.headers["authorization"]
            }
        };
        if (typeof valueOrPolicy === "string") {
            if (!context.auth?.apiKey) {
                console.error("THROWING UNAUTHENTICATED");
                throw new import_error.UserFacingError("UNAUTHENTICATED", "Unauthenticated");
            }
            if (context.auth?.apiKey != valueOrPolicy) {
                console.error("Throwing PERMISSION_DENIED");
                throw new import_error.UserFacingError("PERMISSION_DENIED", "Permission Denied");
            }
        } else if (typeof valueOrPolicy === "function") {
            await valueOrPolicy(context);
        } else if (typeof valueOrPolicy !== "undefined") {
            throw new Error(`Invalid type ${typeof valueOrPolicy} passed to apiKey()`);
        }
        return context;
    };
}
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
    apiKey,
    getContext,
    runWithContext
}); //# sourceMappingURL=context.js.map
}}),
"[project]/node_modules/@genkit-ai/core/lib/schema.js [app-rsc] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all)=>{
    for(var name in all)__defProp(target, name, {
        get: all[name],
        enumerable: true
    });
};
var __copyProps = (to, from, except, desc)=>{
    if (from && typeof from === "object" || typeof from === "function") {
        for (let key of __getOwnPropNames(from))if (!__hasOwnProp.call(to, key) && key !== except) __defProp(to, key, {
            get: ()=>from[key],
            enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable
        });
    }
    return to;
};
var __toESM = (mod, isNodeMode, target)=>(target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(// If the importer is in node compatibility mode or this is not an ESM
    // file that has been converted to a CommonJS file using a Babel-
    // compatible transform (i.e. "__esModule" has not been set), then set
    // "default" to the CommonJS "module.exports" for node compatibility.
    isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", {
        value: mod,
        enumerable: true
    }) : target, mod));
var __toCommonJS = (mod)=>__copyProps(__defProp({}, "__esModule", {
        value: true
    }), mod);
var schema_exports = {};
__export(schema_exports, {
    ValidationError: ()=>ValidationError,
    defineJsonSchema: ()=>defineJsonSchema,
    defineSchema: ()=>defineSchema,
    parseSchema: ()=>parseSchema,
    toJsonSchema: ()=>toJsonSchema,
    validateSchema: ()=>validateSchema,
    z: ()=>import_zod.z
});
module.exports = __toCommonJS(schema_exports);
var import_ajv = __toESM(__turbopack_context__.r("[project]/node_modules/ajv/dist/ajv.js [app-rsc] (ecmascript)"));
var import_ajv_formats = __toESM(__turbopack_context__.r("[project]/node_modules/ajv-formats/dist/index.js [app-rsc] (ecmascript)"));
var import_zod = __turbopack_context__.r("[project]/node_modules/zod/lib/index.js [app-rsc] (ecmascript)");
var import_zod_to_json_schema = __toESM(__turbopack_context__.r("[project]/node_modules/zod-to-json-schema/dist/cjs/index.js [app-rsc] (ecmascript)"));
var import_error = __turbopack_context__.r("[project]/node_modules/@genkit-ai/core/lib/error.js [app-rsc] (ecmascript)");
const ajv = new import_ajv.default();
(0, import_ajv_formats.default)(ajv);
const jsonSchemas = /* @__PURE__ */ new WeakMap();
const validators = /* @__PURE__ */ new WeakMap();
class ValidationError extends import_error.GenkitError {
    constructor({ data, errors, schema }){
        super({
            status: "INVALID_ARGUMENT",
            message: `Schema validation failed. Parse Errors:

${errors.map((e)=>`- ${e.path}: ${e.message}`).join("\n")}

Provided data:

${JSON.stringify(data, null, 2)}

Required JSON schema:

${JSON.stringify(schema, null, 2)}`,
            detail: {
                errors,
                schema
            }
        });
    }
}
function toJsonSchema({ jsonSchema, schema }) {
    if (!jsonSchema && !schema) return null;
    if (jsonSchema) return jsonSchema;
    if (jsonSchemas.has(schema)) return jsonSchemas.get(schema);
    const outSchema = (0, import_zod_to_json_schema.default)(schema, {
        $refStrategy: "none",
        removeAdditionalStrategy: "strict"
    });
    jsonSchemas.set(schema, outSchema);
    return outSchema;
}
function toErrorDetail(error) {
    return {
        path: error.instancePath.substring(1).replace(/\//g, ".") || "(root)",
        message: error.message
    };
}
function validateSchema(data, options) {
    const toValidate = toJsonSchema(options);
    if (!toValidate) {
        return {
            valid: true,
            schema: toValidate
        };
    }
    const validator = validators.get(toValidate) || ajv.compile(toValidate);
    const valid = validator(data);
    const errors = validator.errors?.map((e)=>e);
    return {
        valid,
        errors: errors?.map(toErrorDetail),
        schema: toValidate
    };
}
function parseSchema(data, options) {
    const { valid, errors, schema } = validateSchema(data, options);
    if (!valid) throw new ValidationError({
        data,
        errors,
        schema
    });
    return data;
}
function defineSchema(registry, name, schema) {
    registry.registerSchema(name, {
        schema
    });
    return schema;
}
function defineJsonSchema(registry, name, jsonSchema) {
    registry.registerSchema(name, {
        jsonSchema
    });
    return jsonSchema;
}
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
    ValidationError,
    defineJsonSchema,
    defineSchema,
    parseSchema,
    toJsonSchema,
    validateSchema,
    z
}); //# sourceMappingURL=schema.js.map
}}),
"[project]/node_modules/@genkit-ai/core/lib/logging.js [app-rsc] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all)=>{
    for(var name in all)__defProp(target, name, {
        get: all[name],
        enumerable: true
    });
};
var __copyProps = (to, from, except, desc)=>{
    if (from && typeof from === "object" || typeof from === "function") {
        for (let key of __getOwnPropNames(from))if (!__hasOwnProp.call(to, key) && key !== except) __defProp(to, key, {
            get: ()=>from[key],
            enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable
        });
    }
    return to;
};
var __toCommonJS = (mod)=>__copyProps(__defProp({}, "__esModule", {
        value: true
    }), mod);
var logging_exports = {};
__export(logging_exports, {
    logger: ()=>logger
});
module.exports = __toCommonJS(logging_exports);
const LOG_LEVELS = [
    "debug",
    "info",
    "warn",
    "error"
];
const loggerKey = "__genkit_logger";
const _defaultLogger = {
    shouldLog (targetLevel) {
        return LOG_LEVELS.indexOf(this.level) <= LOG_LEVELS.indexOf(targetLevel);
    },
    debug (...args) {
        this.shouldLog("debug") && console.debug(...args);
    },
    info (...args) {
        this.shouldLog("info") && console.info(...args);
    },
    warn (...args) {
        this.shouldLog("warn") && console.warn(...args);
    },
    error (...args) {
        this.shouldLog("error") && console.error(...args);
    },
    level: "info"
};
function getLogger() {
    if (!global[loggerKey]) {
        global[loggerKey] = _defaultLogger;
    }
    return global[loggerKey];
}
class Logger {
    defaultLogger = _defaultLogger;
    init(fn) {
        global[loggerKey] = fn;
    }
    info(...args) {
        getLogger().info.apply(getLogger(), args);
    }
    debug(...args) {
        getLogger().debug.apply(getLogger(), args);
    }
    error(...args) {
        getLogger().error.apply(getLogger(), args);
    }
    warn(...args) {
        getLogger().warn.apply(getLogger(), args);
    }
    setLogLevel(level) {
        getLogger().level = level;
    }
    logStructured(msg, metadata) {
        getLogger().info(msg, metadata);
    }
    logStructuredError(msg, metadata) {
        getLogger().error(msg, metadata);
    }
}
const logger = new Logger();
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
    logger
}); //# sourceMappingURL=logging.js.map
}}),
"[project]/node_modules/@genkit-ai/core/lib/utils.js [app-rsc] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all)=>{
    for(var name in all)__defProp(target, name, {
        get: all[name],
        enumerable: true
    });
};
var __copyProps = (to, from, except, desc)=>{
    if (from && typeof from === "object" || typeof from === "function") {
        for (let key of __getOwnPropNames(from))if (!__hasOwnProp.call(to, key) && key !== except) __defProp(to, key, {
            get: ()=>from[key],
            enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable
        });
    }
    return to;
};
var __toCommonJS = (mod)=>__copyProps(__defProp({}, "__esModule", {
        value: true
    }), mod);
var utils_exports = {};
__export(utils_exports, {
    deleteUndefinedProps: ()=>deleteUndefinedProps,
    featureMetadataPrefix: ()=>featureMetadataPrefix,
    getCurrentEnv: ()=>getCurrentEnv,
    isDevEnv: ()=>isDevEnv,
    stripUndefinedProps: ()=>stripUndefinedProps
});
module.exports = __toCommonJS(utils_exports);
function deleteUndefinedProps(obj) {
    for(const prop in obj){
        if (obj[prop] === void 0) {
            delete obj[prop];
        } else {
            if (typeof obj[prop] === "object") {
                deleteUndefinedProps(obj[prop]);
            }
        }
    }
}
function stripUndefinedProps(input) {
    if (input === void 0 || input === null || Array.isArray(input) || typeof input !== "object") {
        return input;
    }
    const out = {};
    for(const key in input){
        if (input[key] !== void 0) {
            out[key] = stripUndefinedProps(input[key]);
        }
    }
    return out;
}
function getCurrentEnv() {
    return process.env.GENKIT_ENV || "prod";
}
function isDevEnv() {
    return getCurrentEnv() === "dev";
}
function featureMetadataPrefix(name) {
    return `feature:${name}`;
}
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
    deleteUndefinedProps,
    featureMetadataPrefix,
    getCurrentEnv,
    isDevEnv,
    stripUndefinedProps
}); //# sourceMappingURL=utils.js.map
}}),
"[project]/node_modules/@genkit-ai/core/lib/tracing/exporter.js [app-rsc] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all)=>{
    for(var name in all)__defProp(target, name, {
        get: all[name],
        enumerable: true
    });
};
var __copyProps = (to, from, except, desc)=>{
    if (from && typeof from === "object" || typeof from === "function") {
        for (let key of __getOwnPropNames(from))if (!__hasOwnProp.call(to, key) && key !== except) __defProp(to, key, {
            get: ()=>from[key],
            enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable
        });
    }
    return to;
};
var __toCommonJS = (mod)=>__copyProps(__defProp({}, "__esModule", {
        value: true
    }), mod);
var exporter_exports = {};
__export(exporter_exports, {
    TraceServerExporter: ()=>TraceServerExporter,
    setTelemetryServerUrl: ()=>setTelemetryServerUrl,
    telemetryServerUrl: ()=>telemetryServerUrl
});
module.exports = __toCommonJS(exporter_exports);
var import_api = __turbopack_context__.r("[externals]/@opentelemetry/api [external] (@opentelemetry/api, cjs)");
var import_core = __turbopack_context__.r("[project]/node_modules/@opentelemetry/core/build/esm/index.js [app-rsc] (ecmascript)");
var import_logging = __turbopack_context__.r("[project]/node_modules/@genkit-ai/core/lib/logging.js [app-rsc] (ecmascript)");
var import_utils = __turbopack_context__.r("[project]/node_modules/@genkit-ai/core/lib/utils.js [app-rsc] (ecmascript)");
let telemetryServerUrl;
function setTelemetryServerUrl(url) {
    telemetryServerUrl = url;
}
class TraceServerExporter {
    /**
   * Export spans.
   * @param spans
   * @param resultCallback
   */ export(spans, resultCallback) {
        this._sendSpans(spans, resultCallback);
    }
    /**
   * Shutdown the exporter.
   */ shutdown() {
        this._sendSpans([]);
        return this.forceFlush();
    }
    /**
   * Converts span info into trace store format.
   * @param span
   */ _exportInfo(span) {
        const spanData = {
            spanId: span.spanContext().spanId,
            traceId: span.spanContext().traceId,
            startTime: transformTime(span.startTime),
            endTime: transformTime(span.endTime),
            attributes: {
                ...span.attributes
            },
            displayName: span.name,
            links: span.links,
            spanKind: import_api.SpanKind[span.kind],
            parentSpanId: span.parentSpanId,
            sameProcessAsParentSpan: {
                value: !span.spanContext().isRemote
            },
            status: span.status,
            timeEvents: {
                timeEvent: span.events.map((e)=>({
                        time: transformTime(e.time),
                        annotation: {
                            attributes: e.attributes ?? {},
                            description: e.name
                        }
                    }))
            }
        };
        if (span.instrumentationLibrary !== void 0) {
            spanData.instrumentationLibrary = {
                name: span.instrumentationLibrary.name
            };
            if (span.instrumentationLibrary.schemaUrl !== void 0) {
                spanData.instrumentationLibrary.schemaUrl = span.instrumentationLibrary.schemaUrl;
            }
            if (span.instrumentationLibrary.version !== void 0) {
                spanData.instrumentationLibrary.version = span.instrumentationLibrary.version;
            }
        }
        (0, import_utils.deleteUndefinedProps)(spanData);
        return spanData;
    }
    /**
   * Exports any pending spans in exporter
   */ forceFlush() {
        return Promise.resolve();
    }
    async _sendSpans(spans, done) {
        const traces = {};
        for (const span of spans){
            if (!traces[span.spanContext().traceId]) {
                traces[span.spanContext().traceId] = [];
            }
            traces[span.spanContext().traceId].push(span);
        }
        let error = false;
        for (const traceId of Object.keys(traces)){
            try {
                await this.save(traceId, traces[traceId]);
            } catch (e) {
                error = true;
                import_logging.logger.error(`Failed to save trace ${traceId}`, e);
            }
            if (done) {
                return done({
                    code: error ? import_core.ExportResultCode.FAILED : import_core.ExportResultCode.SUCCESS
                });
            }
        }
    }
    async save(traceId, spans) {
        if (!telemetryServerUrl) {
            import_logging.logger.debug(`Telemetry server is not configured, trace ${traceId} not saved!`);
            return;
        }
        const data = {
            traceId,
            spans: {}
        };
        for (const span of spans){
            const convertedSpan = this._exportInfo(span);
            data.spans[convertedSpan.spanId] = convertedSpan;
            if (!convertedSpan.parentSpanId) {
                data.displayName = convertedSpan.displayName;
                data.startTime = convertedSpan.startTime;
                data.endTime = convertedSpan.endTime;
            }
        }
        await fetch(`${telemetryServerUrl}/api/traces`, {
            method: "POST",
            headers: {
                Accept: "application/json",
                "Content-Type": "application/json"
            },
            body: JSON.stringify(data)
        });
    }
}
function transformTime(time) {
    return (0, import_core.hrTimeToMilliseconds)(time);
}
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
    TraceServerExporter,
    setTelemetryServerUrl,
    telemetryServerUrl
}); //# sourceMappingURL=exporter.js.map
}}),
"[project]/node_modules/@genkit-ai/core/lib/tracing/instrumentation.js [app-rsc] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all)=>{
    for(var name in all)__defProp(target, name, {
        get: all[name],
        enumerable: true
    });
};
var __copyProps = (to, from, except, desc)=>{
    if (from && typeof from === "object" || typeof from === "function") {
        for (let key of __getOwnPropNames(from))if (!__hasOwnProp.call(to, key) && key !== except) __defProp(to, key, {
            get: ()=>from[key],
            enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable
        });
    }
    return to;
};
var __toCommonJS = (mod)=>__copyProps(__defProp({}, "__esModule", {
        value: true
    }), mod);
var instrumentation_exports = {};
__export(instrumentation_exports, {
    ATTR_PREFIX: ()=>ATTR_PREFIX,
    SPAN_TYPE_ATTR: ()=>SPAN_TYPE_ATTR,
    appendSpan: ()=>appendSpan,
    newTrace: ()=>newTrace,
    runInNewSpan: ()=>runInNewSpan,
    setCustomMetadataAttribute: ()=>setCustomMetadataAttribute,
    setCustomMetadataAttributes: ()=>setCustomMetadataAttributes,
    spanMetadataAlsKey: ()=>spanMetadataAlsKey,
    toDisplayPath: ()=>toDisplayPath,
    traceMetadataAlsKey: ()=>traceMetadataAlsKey
});
module.exports = __toCommonJS(instrumentation_exports);
var import_api = __turbopack_context__.r("[externals]/@opentelemetry/api [external] (@opentelemetry/api, cjs)");
var import_node_perf_hooks = __turbopack_context__.r("[externals]/node:perf_hooks [external] (node:perf_hooks, cjs)");
var import_tracing = __turbopack_context__.r("[project]/node_modules/@genkit-ai/core/lib/tracing.js [app-rsc] (ecmascript)");
const spanMetadataAlsKey = "core.tracing.instrumentation.span";
const traceMetadataAlsKey = "core.tracing.instrumentation.trace";
const ATTR_PREFIX = "genkit";
const SPAN_TYPE_ATTR = ATTR_PREFIX + ":type";
const TRACER_NAME = "genkit-tracer";
const TRACER_VERSION = "v1";
async function newTrace(registry, opts, fn) {
    registry = registry.registry ? registry.registry : registry;
    await (0, import_tracing.ensureBasicTelemetryInstrumentation)();
    const traceMetadata = registry.asyncStore.getStore(traceMetadataAlsKey) || {
        paths: /* @__PURE__ */ new Set(),
        timestamp: import_node_perf_hooks.performance.now(),
        featureName: opts.name
    };
    return await registry.asyncStore.run(traceMetadataAlsKey, traceMetadata, ()=>runInNewSpan(registry, {
            metadata: {
                name: opts.name
            },
            labels: opts.labels,
            links: opts.links
        }, async (metadata, otSpan)=>{
            return await fn(metadata, otSpan);
        }));
}
async function runInNewSpan(registry, opts, fn) {
    await (0, import_tracing.ensureBasicTelemetryInstrumentation)();
    const resolvedRegistry = registry.registry ? registry.registry : registry;
    const tracer = import_api.trace.getTracer(TRACER_NAME, TRACER_VERSION);
    const parentStep = resolvedRegistry.asyncStore.getStore(spanMetadataAlsKey);
    const isInRoot = parentStep?.isRoot === true;
    if (!parentStep) opts.metadata.isRoot ||= true;
    return await tracer.startActiveSpan(opts.metadata.name, {
        links: opts.links,
        root: opts.metadata.isRoot
    }, async (otSpan)=>{
        if (opts.labels) otSpan.setAttributes(opts.labels);
        try {
            opts.metadata.path = buildPath(opts.metadata.name, parentStep?.path || "", opts.labels);
            const output = await resolvedRegistry.asyncStore.run(spanMetadataAlsKey, opts.metadata, ()=>fn(opts.metadata, otSpan, isInRoot));
            if (opts.metadata.state !== "error") {
                opts.metadata.state = "success";
            }
            recordPath(resolvedRegistry, opts.metadata);
            return output;
        } catch (e) {
            recordPath(resolvedRegistry, opts.metadata, e);
            opts.metadata.state = "error";
            otSpan.setStatus({
                code: import_api.SpanStatusCode.ERROR,
                message: getErrorMessage(e)
            });
            if (e instanceof Error) {
                otSpan.recordException(e);
            }
            throw e;
        } finally{
            otSpan.setAttributes(metadataToAttributes(opts.metadata));
            otSpan.end();
        }
    });
}
async function appendSpan(traceId, parentSpanId, metadata, labels) {
    await (0, import_tracing.ensureBasicTelemetryInstrumentation)();
    const tracer = import_api.trace.getTracer(TRACER_NAME, TRACER_VERSION);
    const spanContext = import_api.trace.setSpanContext(import_api.ROOT_CONTEXT, {
        traceId,
        traceFlags: 1,
        // sampled
        spanId: parentSpanId
    });
    const span = tracer.startSpan(metadata.name, {}, spanContext);
    span.setAttributes(metadataToAttributes(metadata));
    if (labels) {
        span.setAttributes(labels);
    }
    span.end();
}
function getErrorMessage(e) {
    if (e instanceof Error) {
        return e.message;
    }
    return `${e}`;
}
function metadataToAttributes(metadata) {
    const out = {};
    Object.keys(metadata).forEach((key)=>{
        if (key === "metadata" && typeof metadata[key] === "object" && metadata.metadata) {
            Object.entries(metadata.metadata).forEach(([metaKey, value])=>{
                out[ATTR_PREFIX + ":metadata:" + metaKey] = value;
            });
        } else if (key === "input" || typeof metadata[key] === "object") {
            out[ATTR_PREFIX + ":" + key] = JSON.stringify(metadata[key]);
        } else {
            out[ATTR_PREFIX + ":" + key] = metadata[key];
        }
    });
    return out;
}
function setCustomMetadataAttribute(registry, key, value) {
    const currentStep = getCurrentSpan(registry);
    if (!currentStep) {
        return;
    }
    if (!currentStep.metadata) {
        currentStep.metadata = {};
    }
    currentStep.metadata[key] = value;
}
function setCustomMetadataAttributes(registry, values) {
    const currentStep = getCurrentSpan(registry);
    if (!currentStep) {
        return;
    }
    if (!currentStep.metadata) {
        currentStep.metadata = {};
    }
    for (const [key, value] of Object.entries(values)){
        currentStep.metadata[key] = value;
    }
}
function toDisplayPath(path) {
    const pathPartRegex = /\{([^\,}]+),[^\}]+\}/g;
    return Array.from(path.matchAll(pathPartRegex), (m)=>m[1]).join(" > ");
}
function getCurrentSpan(registry) {
    const step = registry.asyncStore.getStore(spanMetadataAlsKey);
    if (!step) {
        throw new Error("running outside step context");
    }
    return step;
}
function buildPath(name, parentPath, labels) {
    const stepType = labels && labels["genkit:type"] ? `,t:${labels["genkit:metadata:subtype"] === "flow" ? "flow" : labels["genkit:type"]}` : "";
    return parentPath + `/{${name}${stepType}}`;
}
function recordPath(registry, spanMeta, err) {
    const path = spanMeta.path || "";
    const decoratedPath = decoratePathWithSubtype(spanMeta);
    const paths = Array.from(registry.asyncStore.getStore(traceMetadataAlsKey)?.paths || /* @__PURE__ */ new Set());
    const status = err ? "failure" : "success";
    if (!paths.some((p)=>p.path.startsWith(path) && p.status === status)) {
        const now = import_node_perf_hooks.performance.now();
        const start = registry.asyncStore.getStore(traceMetadataAlsKey)?.timestamp || now;
        registry.asyncStore.getStore(traceMetadataAlsKey)?.paths?.add({
            path: decoratedPath,
            error: err?.name,
            latency: now - start,
            status
        });
    }
    spanMeta.path = decoratedPath;
}
function decoratePathWithSubtype(metadata) {
    if (!metadata.path) {
        return "";
    }
    const pathComponents = metadata.path.split("}/{");
    if (pathComponents.length == 1) {
        return metadata.path;
    }
    const stepSubtype = metadata.metadata && metadata.metadata["subtype"] ? `,s:${metadata.metadata["subtype"]}` : "";
    const root = `${pathComponents.slice(0, -1).join("}/{")}}/`;
    const decoratedStep = `{${pathComponents.at(-1)?.slice(0, -1)}${stepSubtype}}`;
    return root + decoratedStep;
}
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
    ATTR_PREFIX,
    SPAN_TYPE_ATTR,
    appendSpan,
    newTrace,
    runInNewSpan,
    setCustomMetadataAttribute,
    setCustomMetadataAttributes,
    spanMetadataAlsKey,
    toDisplayPath,
    traceMetadataAlsKey
}); //# sourceMappingURL=instrumentation.js.map
}}),
"[project]/node_modules/@genkit-ai/core/lib/tracing/processor.js [app-rsc] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all)=>{
    for(var name in all)__defProp(target, name, {
        get: all[name],
        enumerable: true
    });
};
var __copyProps = (to, from, except, desc)=>{
    if (from && typeof from === "object" || typeof from === "function") {
        for (let key of __getOwnPropNames(from))if (!__hasOwnProp.call(to, key) && key !== except) __defProp(to, key, {
            get: ()=>from[key],
            enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable
        });
    }
    return to;
};
var __toCommonJS = (mod)=>__copyProps(__defProp({}, "__esModule", {
        value: true
    }), mod);
var processor_exports = {};
__export(processor_exports, {
    GenkitSpanProcessorWrapper: ()=>GenkitSpanProcessorWrapper
});
module.exports = __toCommonJS(processor_exports);
var import_instrumentation = __turbopack_context__.r("[project]/node_modules/@genkit-ai/core/lib/tracing/instrumentation.js [app-rsc] (ecmascript)");
class GenkitSpanProcessorWrapper {
    constructor(processor){
        this.processor = processor;
    }
    forceFlush() {
        return this.processor.forceFlush();
    }
    onStart(span, parentContext) {
        return this.processor.onStart(span, parentContext);
    }
    onEnd(span) {
        if (Object.keys(span.attributes).find((k)=>k.startsWith(import_instrumentation.ATTR_PREFIX + ":"))) {
            return this.processor.onEnd(new FilteringReadableSpanProxy(span));
        } else {
            return this.processor.onEnd(span);
        }
    }
    async shutdown() {
        return this.processor.shutdown();
    }
}
class FilteringReadableSpanProxy {
    constructor(span){
        this.span = span;
    }
    get name() {
        return this.span.name;
    }
    get kind() {
        return this.span.kind;
    }
    get parentSpanId() {
        return this.span.parentSpanId;
    }
    get startTime() {
        return this.span.startTime;
    }
    get endTime() {
        return this.span.endTime;
    }
    get status() {
        return this.span.status;
    }
    get attributes() {
        const out = {};
        for (const [key, value] of Object.entries(this.span.attributes)){
            if (!key.startsWith(import_instrumentation.ATTR_PREFIX + ":")) {
                out[key] = value;
            }
        }
        return out;
    }
    get links() {
        return this.span.links;
    }
    get events() {
        return this.span.events;
    }
    get duration() {
        return this.span.duration;
    }
    get ended() {
        return this.span.ended;
    }
    get resource() {
        return this.span.resource;
    }
    get instrumentationLibrary() {
        return this.span.instrumentationLibrary;
    }
    get droppedAttributesCount() {
        return this.span.droppedAttributesCount;
    }
    get droppedEventsCount() {
        return this.span.droppedEventsCount;
    }
    get droppedLinksCount() {
        return this.span.droppedLinksCount;
    }
    spanContext() {
        return this.span.spanContext();
    }
}
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
    GenkitSpanProcessorWrapper
}); //# sourceMappingURL=processor.js.map
}}),
"[project]/node_modules/@genkit-ai/core/lib/tracing/types.js [app-rsc] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all)=>{
    for(var name in all)__defProp(target, name, {
        get: all[name],
        enumerable: true
    });
};
var __copyProps = (to, from, except, desc)=>{
    if (from && typeof from === "object" || typeof from === "function") {
        for (let key of __getOwnPropNames(from))if (!__hasOwnProp.call(to, key) && key !== except) __defProp(to, key, {
            get: ()=>from[key],
            enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable
        });
    }
    return to;
};
var __toCommonJS = (mod)=>__copyProps(__defProp({}, "__esModule", {
        value: true
    }), mod);
var types_exports = {};
__export(types_exports, {
    InstrumentationLibrarySchema: ()=>InstrumentationLibrarySchema,
    LinkSchema: ()=>LinkSchema,
    PathMetadataSchema: ()=>PathMetadataSchema,
    SpanContextSchema: ()=>SpanContextSchema,
    SpanDataSchema: ()=>SpanDataSchema,
    SpanMetadataSchema: ()=>SpanMetadataSchema,
    SpanStatusSchema: ()=>SpanStatusSchema,
    TimeEventSchema: ()=>TimeEventSchema,
    TraceDataSchema: ()=>TraceDataSchema,
    TraceMetadataSchema: ()=>TraceMetadataSchema
});
module.exports = __toCommonJS(types_exports);
var import_zod = __turbopack_context__.r("[project]/node_modules/zod/lib/index.js [app-rsc] (ecmascript)");
const PathMetadataSchema = import_zod.z.object({
    path: import_zod.z.string(),
    status: import_zod.z.string(),
    error: import_zod.z.string().optional(),
    latency: import_zod.z.number()
});
const TraceMetadataSchema = import_zod.z.object({
    featureName: import_zod.z.string().optional(),
    paths: import_zod.z.set(PathMetadataSchema).optional(),
    timestamp: import_zod.z.number()
});
const SpanMetadataSchema = import_zod.z.object({
    name: import_zod.z.string(),
    state: import_zod.z.enum([
        "success",
        "error"
    ]).optional(),
    input: import_zod.z.any().optional(),
    output: import_zod.z.any().optional(),
    isRoot: import_zod.z.boolean().optional(),
    metadata: import_zod.z.record(import_zod.z.string(), import_zod.z.string()).optional(),
    path: import_zod.z.string().optional()
});
const SpanStatusSchema = import_zod.z.object({
    code: import_zod.z.number(),
    message: import_zod.z.string().optional()
});
const TimeEventSchema = import_zod.z.object({
    time: import_zod.z.number(),
    annotation: import_zod.z.object({
        attributes: import_zod.z.record(import_zod.z.string(), import_zod.z.any()),
        description: import_zod.z.string()
    })
});
const SpanContextSchema = import_zod.z.object({
    traceId: import_zod.z.string(),
    spanId: import_zod.z.string(),
    isRemote: import_zod.z.boolean().optional(),
    traceFlags: import_zod.z.number()
});
const LinkSchema = import_zod.z.object({
    context: SpanContextSchema.optional(),
    attributes: import_zod.z.record(import_zod.z.string(), import_zod.z.any()).optional(),
    droppedAttributesCount: import_zod.z.number().optional()
});
const InstrumentationLibrarySchema = import_zod.z.object({
    name: import_zod.z.string().readonly(),
    version: import_zod.z.string().optional().readonly(),
    schemaUrl: import_zod.z.string().optional().readonly()
});
const SpanDataSchema = import_zod.z.object({
    spanId: import_zod.z.string(),
    traceId: import_zod.z.string(),
    parentSpanId: import_zod.z.string().optional(),
    startTime: import_zod.z.number(),
    endTime: import_zod.z.number(),
    attributes: import_zod.z.record(import_zod.z.string(), import_zod.z.any()),
    displayName: import_zod.z.string(),
    links: import_zod.z.array(LinkSchema).optional(),
    instrumentationLibrary: InstrumentationLibrarySchema,
    spanKind: import_zod.z.string(),
    sameProcessAsParentSpan: import_zod.z.object({
        value: import_zod.z.boolean()
    }).optional(),
    status: SpanStatusSchema.optional(),
    timeEvents: import_zod.z.object({
        timeEvent: import_zod.z.array(TimeEventSchema)
    }).optional(),
    truncated: import_zod.z.boolean().optional()
});
const TraceDataSchema = import_zod.z.object({
    traceId: import_zod.z.string(),
    displayName: import_zod.z.string().optional(),
    startTime: import_zod.z.number().optional().describe("trace start time in milliseconds since the epoch"),
    endTime: import_zod.z.number().optional().describe("end time in milliseconds since the epoch"),
    spans: import_zod.z.record(import_zod.z.string(), SpanDataSchema)
});
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
    InstrumentationLibrarySchema,
    LinkSchema,
    PathMetadataSchema,
    SpanContextSchema,
    SpanDataSchema,
    SpanMetadataSchema,
    SpanStatusSchema,
    TimeEventSchema,
    TraceDataSchema,
    TraceMetadataSchema
}); //# sourceMappingURL=types.js.map
}}),
"[project]/node_modules/@genkit-ai/core/lib/tracing.js [app-rsc] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all)=>{
    for(var name in all)__defProp(target, name, {
        get: all[name],
        enumerable: true
    });
};
var __copyProps = (to, from, except, desc)=>{
    if (from && typeof from === "object" || typeof from === "function") {
        for (let key of __getOwnPropNames(from))if (!__hasOwnProp.call(to, key) && key !== except) __defProp(to, key, {
            get: ()=>from[key],
            enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable
        });
    }
    return to;
};
var __reExport = (target, mod, secondTarget)=>(__copyProps(target, mod, "default"), secondTarget && __copyProps(secondTarget, mod, "default"));
var __toCommonJS = (mod)=>__copyProps(__defProp({}, "__esModule", {
        value: true
    }), mod);
var tracing_exports = {};
__export(tracing_exports, {
    cleanUpTracing: ()=>cleanUpTracing,
    enableTelemetry: ()=>enableTelemetry,
    ensureBasicTelemetryInstrumentation: ()=>ensureBasicTelemetryInstrumentation,
    flushTracing: ()=>flushTracing
});
module.exports = __toCommonJS(tracing_exports);
var import_sdk_node = __turbopack_context__.r("[project]/node_modules/@opentelemetry/sdk-node/build/src/index.js [app-rsc] (ecmascript)");
var import_sdk_trace_base = __turbopack_context__.r("[project]/node_modules/@opentelemetry/sdk-trace-base/build/esm/index.js [app-rsc] (ecmascript)");
var import_logging = __turbopack_context__.r("[project]/node_modules/@genkit-ai/core/lib/logging.js [app-rsc] (ecmascript)");
var import_exporter = __turbopack_context__.r("[project]/node_modules/@genkit-ai/core/lib/tracing/exporter.js [app-rsc] (ecmascript)");
var import_utils = __turbopack_context__.r("[project]/node_modules/@genkit-ai/core/lib/utils.js [app-rsc] (ecmascript)");
__reExport(tracing_exports, __turbopack_context__.r("[project]/node_modules/@genkit-ai/core/lib/tracing/exporter.js [app-rsc] (ecmascript)"), module.exports);
__reExport(tracing_exports, __turbopack_context__.r("[project]/node_modules/@genkit-ai/core/lib/tracing/instrumentation.js [app-rsc] (ecmascript)"), module.exports);
__reExport(tracing_exports, __turbopack_context__.r("[project]/node_modules/@genkit-ai/core/lib/tracing/processor.js [app-rsc] (ecmascript)"), module.exports);
__reExport(tracing_exports, __turbopack_context__.r("[project]/node_modules/@genkit-ai/core/lib/tracing/types.js [app-rsc] (ecmascript)"), module.exports);
let telemetrySDK = null;
let nodeOtelConfig = null;
const instrumentationKey = "__GENKIT_TELEMETRY_INSTRUMENTED";
async function ensureBasicTelemetryInstrumentation() {
    if (global[instrumentationKey]) {
        return await global[instrumentationKey];
    }
    await enableTelemetry({});
}
async function enableTelemetry(telemetryConfig) {
    if (process.env.GENKIT_TELEMETRY_SERVER) {
        (0, import_exporter.setTelemetryServerUrl)(process.env.GENKIT_TELEMETRY_SERVER);
    }
    global[instrumentationKey] = telemetryConfig instanceof Promise ? telemetryConfig : Promise.resolve();
    telemetryConfig = telemetryConfig instanceof Promise ? await telemetryConfig : telemetryConfig;
    nodeOtelConfig = telemetryConfig || {};
    const processors = [
        createTelemetryServerProcessor()
    ];
    if (nodeOtelConfig.traceExporter) {
        throw new Error("Please specify spanProcessors instead.");
    }
    if (nodeOtelConfig.spanProcessors) {
        processors.push(...nodeOtelConfig.spanProcessors);
    }
    if (nodeOtelConfig.spanProcessor) {
        processors.push(nodeOtelConfig.spanProcessor);
        delete nodeOtelConfig.spanProcessor;
    }
    nodeOtelConfig.spanProcessors = processors;
    telemetrySDK = new import_sdk_node.NodeSDK(nodeOtelConfig);
    telemetrySDK.start();
    process.on("SIGTERM", async ()=>await cleanUpTracing());
}
async function cleanUpTracing() {
    if (!telemetrySDK) {
        return;
    }
    await maybeFlushMetrics();
    await telemetrySDK.shutdown();
    import_logging.logger.debug("OpenTelemetry SDK shut down.");
    telemetrySDK = null;
}
function createTelemetryServerProcessor() {
    const exporter = new import_exporter.TraceServerExporter();
    return (0, import_utils.isDevEnv)() ? new import_sdk_trace_base.SimpleSpanProcessor(exporter) : new import_sdk_trace_base.BatchSpanProcessor(exporter);
}
function maybeFlushMetrics() {
    if (nodeOtelConfig?.metricReader) {
        return nodeOtelConfig.metricReader.forceFlush();
    }
    return Promise.resolve();
}
async function flushTracing() {
    if (nodeOtelConfig?.spanProcessors) {
        await Promise.all(nodeOtelConfig.spanProcessors.map((p)=>p.forceFlush()));
    }
}
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
    cleanUpTracing,
    enableTelemetry,
    ensureBasicTelemetryInstrumentation,
    flushTracing,
    ...__turbopack_context__.r("[project]/node_modules/@genkit-ai/core/lib/tracing/exporter.js [app-rsc] (ecmascript)"),
    ...__turbopack_context__.r("[project]/node_modules/@genkit-ai/core/lib/tracing/instrumentation.js [app-rsc] (ecmascript)"),
    ...__turbopack_context__.r("[project]/node_modules/@genkit-ai/core/lib/tracing/processor.js [app-rsc] (ecmascript)"),
    ...__turbopack_context__.r("[project]/node_modules/@genkit-ai/core/lib/tracing/types.js [app-rsc] (ecmascript)")
}); //# sourceMappingURL=tracing.js.map
}}),
"[project]/node_modules/@genkit-ai/core/lib/action.js [app-rsc] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all)=>{
    for(var name in all)__defProp(target, name, {
        get: all[name],
        enumerable: true
    });
};
var __copyProps = (to, from, except, desc)=>{
    if (from && typeof from === "object" || typeof from === "function") {
        for (let key of __getOwnPropNames(from))if (!__hasOwnProp.call(to, key) && key !== except) __defProp(to, key, {
            get: ()=>from[key],
            enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable
        });
    }
    return to;
};
var __toCommonJS = (mod)=>__copyProps(__defProp({}, "__esModule", {
        value: true
    }), mod);
var action_exports = {};
__export(action_exports, {
    StatusCodes: ()=>import_statusTypes.StatusCodes,
    StatusSchema: ()=>import_statusTypes.StatusSchema,
    action: ()=>action,
    actionWithMiddleware: ()=>actionWithMiddleware,
    defineAction: ()=>defineAction,
    defineActionAsync: ()=>defineActionAsync,
    getStreamingCallback: ()=>getStreamingCallback,
    isInRuntimeContext: ()=>isInRuntimeContext,
    runInActionRuntimeContext: ()=>runInActionRuntimeContext,
    runOutsideActionRuntimeContext: ()=>runOutsideActionRuntimeContext,
    runWithStreamingCallback: ()=>runWithStreamingCallback,
    sentinelNoopStreamingCallback: ()=>sentinelNoopStreamingCallback
});
module.exports = __toCommonJS(action_exports);
var import_async = __turbopack_context__.r("[project]/node_modules/@genkit-ai/core/lib/async.js [app-rsc] (ecmascript)");
var import_context = __turbopack_context__.r("[project]/node_modules/@genkit-ai/core/lib/context.js [app-rsc] (ecmascript)");
var import_schema = __turbopack_context__.r("[project]/node_modules/@genkit-ai/core/lib/schema.js [app-rsc] (ecmascript)");
var import_tracing = __turbopack_context__.r("[project]/node_modules/@genkit-ai/core/lib/tracing.js [app-rsc] (ecmascript)");
var import_statusTypes = __turbopack_context__.r("[project]/node_modules/@genkit-ai/core/lib/statusTypes.js [app-rsc] (ecmascript)");
function actionWithMiddleware(action2, middleware) {
    const wrapped = async (req)=>{
        return (await wrapped.run(req)).result;
    };
    wrapped.__action = action2.__action;
    wrapped.__registry = action2.__registry;
    wrapped.run = async (req, options)=>{
        let telemetry;
        const dispatch = async (index, req2, opts)=>{
            if (index === middleware.length) {
                const result = await action2.run(req2, opts);
                telemetry = result.telemetry;
                return result.result;
            }
            const currentMiddleware = middleware[index];
            if (currentMiddleware.length === 3) {
                return currentMiddleware(req2, opts, async (modifiedReq, modifiedOptions)=>dispatch(index + 1, modifiedReq || req2, modifiedOptions || opts));
            } else if (currentMiddleware.length === 2) {
                return currentMiddleware(req2, async (modifiedReq)=>dispatch(index + 1, modifiedReq || req2, opts));
            } else {
                throw new Error("unspported middleware function shape");
            }
        };
        wrapped.stream = action2.stream;
        return {
            result: await dispatch(0, req, options),
            telemetry
        };
    };
    return wrapped;
}
function action(registry, config, fn) {
    const actionName = typeof config.name === "string" ? config.name : `${config.name.pluginId}/${config.name.actionId}`;
    const actionFn = async (input, options)=>{
        return (await actionFn.run(input, options)).result;
    };
    actionFn.__registry = registry;
    actionFn.__action = {
        name: actionName,
        description: config.description,
        inputSchema: config.inputSchema,
        inputJsonSchema: config.inputJsonSchema,
        outputSchema: config.outputSchema,
        outputJsonSchema: config.outputJsonSchema,
        streamSchema: config.streamSchema,
        metadata: config.metadata
    };
    actionFn.run = async (input, options)=>{
        input = (0, import_schema.parseSchema)(input, {
            schema: config.inputSchema,
            jsonSchema: config.inputJsonSchema
        });
        let traceId;
        let spanId;
        let output = await (0, import_tracing.newTrace)(registry, {
            name: actionName,
            labels: {
                [import_tracing.SPAN_TYPE_ATTR]: "action",
                "genkit:metadata:subtype": config.actionType,
                ...options?.telemetryLabels
            }
        }, async (metadata, span)=>{
            (0, import_tracing.setCustomMetadataAttributes)(registry, {
                subtype: config.actionType
            });
            if (options?.context) {
                (0, import_tracing.setCustomMetadataAttributes)(registry, {
                    context: JSON.stringify(options.context)
                });
            }
            traceId = span.spanContext().traceId;
            spanId = span.spanContext().spanId;
            metadata.name = actionName;
            metadata.input = input;
            try {
                const actionFn2 = ()=>fn(input, {
                        ...options,
                        // Context can either be explicitly set, or inherited from the parent action.
                        context: options?.context ?? (0, import_context.getContext)(registry),
                        sendChunk: options?.onChunk ?? sentinelNoopStreamingCallback
                    });
                const output2 = await (0, import_context.runWithContext)(registry, options?.context, actionFn2);
                metadata.output = JSON.stringify(output2);
                return output2;
            } catch (err) {
                if (typeof err === "object") {
                    err.traceId = traceId;
                }
                throw err;
            }
        });
        output = (0, import_schema.parseSchema)(output, {
            schema: config.outputSchema,
            jsonSchema: config.outputJsonSchema
        });
        return {
            result: output,
            telemetry: {
                traceId,
                spanId
            }
        };
    };
    actionFn.stream = (input, opts)=>{
        let chunkStreamController;
        const chunkStream = new ReadableStream({
            start (controller) {
                chunkStreamController = controller;
            },
            pull () {},
            cancel () {}
        });
        const invocationPromise = actionFn.run(config.inputSchema ? config.inputSchema.parse(input) : input, {
            onChunk: (chunk)=>{
                chunkStreamController.enqueue(chunk);
            },
            context: opts?.context
        }).then((s)=>s.result).finally(()=>{
            chunkStreamController.close();
        });
        return {
            output: invocationPromise,
            stream: async function*() {
                const reader = chunkStream.getReader();
                while(true){
                    const chunk = await reader.read();
                    if (chunk.value) {
                        yield chunk.value;
                    }
                    if (chunk.done) {
                        break;
                    }
                }
                return await invocationPromise;
            }()
        };
    };
    if (config.use) {
        return actionWithMiddleware(actionFn, config.use);
    }
    return actionFn;
}
function defineAction(registry, config, fn) {
    if (isInRuntimeContext(registry)) {
        throw new Error("Cannot define new actions at runtime.\nSee: https://github.com/firebase/genkit/blob/main/docs/errors/no_new_actions_at_runtime.md");
    }
    const act = action(registry, config, async (i, options)=>{
        await registry.initializeAllPlugins();
        return await runInActionRuntimeContext(registry, ()=>fn(i, options));
    });
    act.__action.actionType = config.actionType;
    registry.registerAction(config.actionType, act);
    return act;
}
function defineActionAsync(registry, actionType, name, config, onInit) {
    const actionName = typeof name === "string" ? name : `${name.pluginId}/${name.actionId}`;
    const actionPromise = (0, import_async.lazy)(()=>config.then((resolvedConfig)=>{
            const act = action(registry, resolvedConfig, async (i, options)=>{
                await registry.initializeAllPlugins();
                return await runInActionRuntimeContext(registry, ()=>resolvedConfig.fn(i, options));
            });
            act.__action.actionType = actionType;
            onInit?.(act);
            return act;
        }));
    registry.registerActionAsync(actionType, actionName, actionPromise);
    return actionPromise;
}
const streamingAlsKey = "core.action.streamingCallback";
const sentinelNoopStreamingCallback = ()=>null;
function runWithStreamingCallback(registry, streamingCallback, fn) {
    return registry.asyncStore.run(streamingAlsKey, streamingCallback || sentinelNoopStreamingCallback, fn);
}
function getStreamingCallback(registry) {
    const cb = registry.asyncStore.getStore(streamingAlsKey);
    if (cb === sentinelNoopStreamingCallback) {
        return void 0;
    }
    return cb;
}
const runtimeContextAslKey = "core.action.runtimeContext";
function isInRuntimeContext(registry) {
    return registry.asyncStore.getStore(runtimeContextAslKey) === "runtime";
}
function runInActionRuntimeContext(registry, fn) {
    return registry.asyncStore.run(runtimeContextAslKey, "runtime", fn);
}
function runOutsideActionRuntimeContext(registry, fn) {
    return registry.asyncStore.run(runtimeContextAslKey, "outside", fn);
}
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
    StatusCodes,
    StatusSchema,
    action,
    actionWithMiddleware,
    defineAction,
    defineActionAsync,
    getStreamingCallback,
    isInRuntimeContext,
    runInActionRuntimeContext,
    runOutsideActionRuntimeContext,
    runWithStreamingCallback,
    sentinelNoopStreamingCallback
}); //# sourceMappingURL=action.js.map
}}),
"[project]/node_modules/@genkit-ai/core/lib/registry.js [app-rsc] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all)=>{
    for(var name in all)__defProp(target, name, {
        get: all[name],
        enumerable: true
    });
};
var __copyProps = (to, from, except, desc)=>{
    if (from && typeof from === "object" || typeof from === "function") {
        for (let key of __getOwnPropNames(from))if (!__hasOwnProp.call(to, key) && key !== except) __defProp(to, key, {
            get: ()=>from[key],
            enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable
        });
    }
    return to;
};
var __toCommonJS = (mod)=>__copyProps(__defProp({}, "__esModule", {
        value: true
    }), mod);
var registry_exports = {};
__export(registry_exports, {
    AsyncStore: ()=>AsyncStore,
    Registry: ()=>Registry
});
module.exports = __toCommonJS(registry_exports);
var import_dotprompt = __turbopack_context__.r("[project]/node_modules/dotprompt/dist/index.js [app-rsc] (ecmascript)");
var import_node_async_hooks = __turbopack_context__.r("[externals]/node:async_hooks [external] (node:async_hooks, cjs)");
var import_action = __turbopack_context__.r("[project]/node_modules/@genkit-ai/core/lib/action.js [app-rsc] (ecmascript)");
var import_error = __turbopack_context__.r("[project]/node_modules/@genkit-ai/core/lib/error.js [app-rsc] (ecmascript)");
var import_logging = __turbopack_context__.r("[project]/node_modules/@genkit-ai/core/lib/logging.js [app-rsc] (ecmascript)");
var import_schema = __turbopack_context__.r("[project]/node_modules/@genkit-ai/core/lib/schema.js [app-rsc] (ecmascript)");
function parsePluginName(registryKey) {
    const tokens = registryKey.split("/");
    if (tokens.length >= 4) {
        return tokens[2];
    }
    return void 0;
}
class Registry {
    constructor(parent){
        this.parent = parent;
    }
    actionsById = {};
    pluginsByName = {};
    schemasByName = {};
    valueByTypeAndName = {};
    allPluginsInitialized = false;
    apiStability = "stable";
    asyncStore = new AsyncStore();
    dotprompt = new import_dotprompt.Dotprompt({
        schemaResolver: async (name)=>{
            const resolvedSchema = await this.lookupSchema(name);
            if (!resolvedSchema) {
                throw new import_error.GenkitError({
                    message: `Schema '${name}' not found`,
                    status: "NOT_FOUND"
                });
            }
            return (0, import_schema.toJsonSchema)(resolvedSchema);
        }
    });
    /**
   * Creates a new registry overlaid onto the provided registry.
   * @param parent The parent registry.
   * @returns The new overlaid registry.
   */ static withParent(parent) {
        return new Registry(parent);
    }
    /**
   * Looks up an action in the registry.
   * @param key The key of the action to lookup.
   * @returns The action.
   */ async lookupAction(key) {
        const pluginName = parsePluginName(key);
        if (!this.actionsById[key] && pluginName) {
            await this.initializePlugin(pluginName);
        }
        return await this.actionsById[key] || this.parent?.lookupAction(key);
    }
    /**
   * Registers an action in the registry.
   * @param type The type of the action to register.
   * @param action The action to register.
   */ registerAction(type, action) {
        const key = `/${type}/${action.__action.name}`;
        import_logging.logger.debug(`registering ${key}`);
        if (this.actionsById.hasOwnProperty(key)) {
            import_logging.logger.warn(`WARNING: ${key} already has an entry in the registry. Overwriting.`);
        }
        this.actionsById[key] = action;
    }
    /**
   * Registers an action promise in the registry.
   */ registerActionAsync(type, name, action) {
        const key = `/${type}/${name}`;
        import_logging.logger.debug(`registering ${key} (async)`);
        if (this.actionsById.hasOwnProperty(key)) {
            import_logging.logger.warn(`WARNING: ${key} already has an entry in the registry. Overwriting.`);
        }
        this.actionsById[key] = action;
    }
    /**
   * Returns all actions in the registry.
   * @returns All actions in the registry.
   */ async listActions() {
        await this.initializeAllPlugins();
        const actions = {};
        await Promise.all(Object.entries(this.actionsById).map(async ([key, action])=>{
            actions[key] = await action;
        }));
        return {
            ...await this.parent?.listActions(),
            ...actions
        };
    }
    /**
   * Initializes all plugins in the registry.
   */ async initializeAllPlugins() {
        if (this.allPluginsInitialized) {
            return;
        }
        for (const pluginName of Object.keys(this.pluginsByName)){
            await this.initializePlugin(pluginName);
        }
        this.allPluginsInitialized = true;
    }
    /**
   * Registers a plugin provider. This plugin must be initialized before it can be used by calling {@link initializePlugin} or {@link initializeAllPlugins}.
   * @param name The name of the plugin to register.
   * @param provider The plugin provider.
   */ registerPluginProvider(name, provider) {
        if (this.pluginsByName[name]) {
            throw new Error(`Plugin ${name} already registered`);
        }
        this.allPluginsInitialized = false;
        let cached;
        let isInitialized = false;
        this.pluginsByName[name] = {
            name: provider.name,
            initializer: ()=>{
                if (!isInitialized) {
                    cached = provider.initializer();
                    isInitialized = true;
                }
                return cached;
            }
        };
    }
    /**
   * Looks up a plugin.
   * @param name The name of the plugin to lookup.
   * @returns The plugin provider.
   */ lookupPlugin(name) {
        return this.pluginsByName[name] || this.parent?.lookupPlugin(name);
    }
    /**
   * Initializes a plugin already registered with {@link registerPluginProvider}.
   * @param name The name of the plugin to initialize.
   * @returns The plugin.
   */ async initializePlugin(name) {
        if (this.pluginsByName[name]) {
            return await (0, import_action.runOutsideActionRuntimeContext)(this, ()=>this.pluginsByName[name].initializer());
        }
    }
    /**
   * Registers a schema.
   * @param name The name of the schema to register.
   * @param data The schema to register (either a Zod schema or a JSON schema).
   */ registerSchema(name, data) {
        if (this.schemasByName[name]) {
            throw new Error(`Schema ${name} already registered`);
        }
        this.schemasByName[name] = data;
    }
    registerValue(type, name, value) {
        if (!this.valueByTypeAndName[type]) {
            this.valueByTypeAndName[type] = {};
        }
        this.valueByTypeAndName[type][name] = value;
    }
    async lookupValue(type, key) {
        const pluginName = parsePluginName(key);
        if (!this.valueByTypeAndName[type]?.[key] && pluginName) {
            await this.initializePlugin(pluginName);
        }
        return this.valueByTypeAndName[type]?.[key] || this.parent?.lookupValue(type, key);
    }
    async listValues(type) {
        await this.initializeAllPlugins();
        return {
            ...await this.parent?.listValues(type) || {},
            ...this.valueByTypeAndName[type] || {}
        };
    }
    /**
   * Looks up a schema.
   * @param name The name of the schema to lookup.
   * @returns The schema.
   */ lookupSchema(name) {
        return this.schemasByName[name] || this.parent?.lookupSchema(name);
    }
}
class AsyncStore {
    asls = {};
    getStore(key) {
        return this.asls[key]?.getStore();
    }
    run(key, store, callback) {
        if (!this.asls[key]) {
            this.asls[key] = new import_node_async_hooks.AsyncLocalStorage();
        }
        return this.asls[key].run(store, callback);
    }
}
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
    AsyncStore,
    Registry
}); //# sourceMappingURL=registry.js.map
}}),
"[project]/node_modules/@genkit-ai/core/lib/flow.js [app-rsc] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all)=>{
    for(var name in all)__defProp(target, name, {
        get: all[name],
        enumerable: true
    });
};
var __copyProps = (to, from, except, desc)=>{
    if (from && typeof from === "object" || typeof from === "function") {
        for (let key of __getOwnPropNames(from))if (!__hasOwnProp.call(to, key) && key !== except) __defProp(to, key, {
            get: ()=>from[key],
            enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable
        });
    }
    return to;
};
var __toCommonJS = (mod)=>__copyProps(__defProp({}, "__esModule", {
        value: true
    }), mod);
var flow_exports = {};
__export(flow_exports, {
    defineFlow: ()=>defineFlow,
    run: ()=>run
});
module.exports = __toCommonJS(flow_exports);
var import_node_async_hooks = __turbopack_context__.r("[externals]/node:async_hooks [external] (node:async_hooks, cjs)");
var import_action = __turbopack_context__.r("[project]/node_modules/@genkit-ai/core/lib/action.js [app-rsc] (ecmascript)");
var import_registry = __turbopack_context__.r("[project]/node_modules/@genkit-ai/core/lib/registry.js [app-rsc] (ecmascript)");
var import_tracing = __turbopack_context__.r("[project]/node_modules/@genkit-ai/core/lib/tracing.js [app-rsc] (ecmascript)");
function defineFlow(registry, config, fn) {
    const resolvedConfig = typeof config === "string" ? {
        name: config
    } : config;
    return defineFlowAction(registry, resolvedConfig, fn);
}
function defineFlowAction(registry, config, fn) {
    return (0, import_action.defineAction)(registry, {
        actionType: "flow",
        name: config.name,
        inputSchema: config.inputSchema,
        outputSchema: config.outputSchema,
        streamSchema: config.streamSchema
    }, async (input, { sendChunk, context })=>{
        return await legacyRegistryAls.run(registry, ()=>{
            const ctx = sendChunk;
            ctx.sendChunk = sendChunk;
            ctx.context = context;
            return fn(input, ctx);
        });
    });
}
const legacyRegistryAls = new import_node_async_hooks.AsyncLocalStorage();
function run(name, funcOrInput, fnOrRegistry, maybeRegistry) {
    let func;
    let input;
    let registry;
    if (typeof funcOrInput === "function") {
        func = funcOrInput;
    } else {
        input = funcOrInput;
    }
    if (typeof fnOrRegistry === "function") {
        func = fnOrRegistry;
    } else if (fnOrRegistry instanceof import_registry.Registry || fnOrRegistry?.registry) {
        registry = fnOrRegistry?.registry ? fnOrRegistry?.registry : fnOrRegistry;
    }
    if (maybeRegistry) {
        registry = maybeRegistry.registry ? maybeRegistry.registry : maybeRegistry;
    }
    if (!registry) {
        registry = legacyRegistryAls.getStore();
    }
    if (!registry) {
        throw new Error("Unable to resolve registry. Consider explicitly passing Genkit instance.");
    }
    if (!func) {
        throw new Error("unable to resolve run function");
    }
    return (0, import_tracing.runInNewSpan)(registry, {
        metadata: {
            name
        },
        labels: {
            [import_tracing.SPAN_TYPE_ATTR]: "flowStep"
        }
    }, async (meta)=>{
        meta.input = input;
        const output = arguments.length === 3 ? await func(input) : await func();
        meta.output = JSON.stringify(output);
        return output;
    });
}
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
    defineFlow,
    run
}); //# sourceMappingURL=flow.js.map
}}),
"[project]/node_modules/@genkit-ai/core/lib/plugin.js [app-rsc] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __copyProps = (to, from, except, desc)=>{
    if (from && typeof from === "object" || typeof from === "function") {
        for (let key of __getOwnPropNames(from))if (!__hasOwnProp.call(to, key) && key !== except) __defProp(to, key, {
            get: ()=>from[key],
            enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable
        });
    }
    return to;
};
var __toCommonJS = (mod)=>__copyProps(__defProp({}, "__esModule", {
        value: true
    }), mod);
var plugin_exports = {};
module.exports = __toCommonJS(plugin_exports); //# sourceMappingURL=plugin.js.map
}}),
"[project]/node_modules/@genkit-ai/core/lib/reflection.js [app-rsc] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all)=>{
    for(var name in all)__defProp(target, name, {
        get: all[name],
        enumerable: true
    });
};
var __copyProps = (to, from, except, desc)=>{
    if (from && typeof from === "object" || typeof from === "function") {
        for (let key of __getOwnPropNames(from))if (!__hasOwnProp.call(to, key) && key !== except) __defProp(to, key, {
            get: ()=>from[key],
            enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable
        });
    }
    return to;
};
var __toESM = (mod, isNodeMode, target)=>(target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(// If the importer is in node compatibility mode or this is not an ESM
    // file that has been converted to a CommonJS file using a Babel-
    // compatible transform (i.e. "__esModule" has not been set), then set
    // "default" to the CommonJS "module.exports" for node compatibility.
    isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", {
        value: mod,
        enumerable: true
    }) : target, mod));
var __toCommonJS = (mod)=>__copyProps(__defProp({}, "__esModule", {
        value: true
    }), mod);
var reflection_exports = {};
__export(reflection_exports, {
    ReflectionServer: ()=>ReflectionServer,
    RunActionResponseSchema: ()=>RunActionResponseSchema
});
module.exports = __toCommonJS(reflection_exports);
var import_express = __toESM(__turbopack_context__.r("[externals]/express [external] (express, cjs)"));
var import_promises = __toESM(__turbopack_context__.r("[externals]/fs/promises [external] (fs/promises, cjs)"));
var import_get_port = __toESM(__turbopack_context__.r("[project]/node_modules/get-port/index.js [app-rsc] (ecmascript)"));
var import_path = __toESM(__turbopack_context__.r("[externals]/path [external] (path, cjs)"));
var z = __toESM(__turbopack_context__.r("[project]/node_modules/zod/lib/index.js [app-rsc] (ecmascript)"));
var import_action = __turbopack_context__.r("[project]/node_modules/@genkit-ai/core/lib/action.js [app-rsc] (ecmascript)");
var import_index = __turbopack_context__.r("[project]/node_modules/@genkit-ai/core/lib/index.js [app-rsc] (ecmascript)");
var import_logging = __turbopack_context__.r("[project]/node_modules/@genkit-ai/core/lib/logging.js [app-rsc] (ecmascript)");
var import_schema = __turbopack_context__.r("[project]/node_modules/@genkit-ai/core/lib/schema.js [app-rsc] (ecmascript)");
var import_tracing = __turbopack_context__.r("[project]/node_modules/@genkit-ai/core/lib/tracing.js [app-rsc] (ecmascript)");
const RunActionResponseSchema = z.object({
    result: z.unknown().optional(),
    error: z.unknown().optional(),
    telemetry: z.object({
        traceId: z.string().optional()
    }).optional()
});
class ReflectionServer {
    /** List of all running servers needed to be cleaned up on process exit. */ static RUNNING_SERVERS = [];
    /** Registry instance to be used for API calls. */ registry;
    /** Options for the reflection server. */ options;
    /** Port the server is actually running on. This may differ from `options.port` if the original was occupied. Null if server is not running. */ port = null;
    /** Express server instance. Null if server is not running. */ server = null;
    /** Path to the runtime file. Null if server is not running. */ runtimeFilePath = null;
    constructor(registry, options){
        this.registry = registry;
        this.options = {
            port: 3100,
            bodyLimit: "30mb",
            configuredEnvs: [
                "dev"
            ],
            ...options
        };
    }
    /**
   * Finds a free port to run the server on based on the original chosen port and environment.
   */ async findPort() {
        const chosenPort = this.options.port;
        const freePort = await (0, import_get_port.default)({
            port: (0, import_get_port.makeRange)(chosenPort, chosenPort + 100)
        });
        if (freePort !== chosenPort) {
            import_logging.logger.warn(`Port ${chosenPort} is already in use, using next available port ${freePort} instead.`);
        }
        return freePort;
    }
    /**
   * Starts the server.
   *
   * The server will be registered to be shut down on process exit.
   */ async start() {
        const server = (0, import_express.default)();
        server.use(import_express.default.json({
            limit: this.options.bodyLimit
        }));
        server.use(function(req, res, next) {
            res.header("x-genkit-version", import_index.GENKIT_VERSION);
            next();
        });
        server.get("/api/__health", async (_, response)=>{
            await this.registry.listActions();
            response.status(200).send("OK");
        });
        server.get("/api/__quitquitquit", async (_, response)=>{
            import_logging.logger.debug("Received quitquitquit");
            response.status(200).send("OK");
            await this.stop();
        });
        server.get("/api/actions", async (_, response, next)=>{
            import_logging.logger.debug("Fetching actions.");
            try {
                const actions = await this.registry.listActions();
                const convertedActions = {};
                Object.keys(actions).forEach((key)=>{
                    const action = actions[key].__action;
                    convertedActions[key] = {
                        key,
                        name: action.name,
                        description: action.description,
                        metadata: action.metadata
                    };
                    if (action.inputSchema || action.inputJsonSchema) {
                        convertedActions[key].inputSchema = (0, import_schema.toJsonSchema)({
                            schema: action.inputSchema,
                            jsonSchema: action.inputJsonSchema
                        });
                    }
                    if (action.outputSchema || action.outputJsonSchema) {
                        convertedActions[key].outputSchema = (0, import_schema.toJsonSchema)({
                            schema: action.outputSchema,
                            jsonSchema: action.outputJsonSchema
                        });
                    }
                });
                response.send(convertedActions);
            } catch (err) {
                const { message, stack } = err;
                next({
                    message,
                    stack
                });
            }
        });
        server.post("/api/runAction", async (request, response, next)=>{
            const { key, input, context, telemetryLabels } = request.body;
            const { stream } = request.query;
            import_logging.logger.debug(`Running action \`${key}\` with stream=${stream}...`);
            try {
                const action = await this.registry.lookupAction(key);
                if (!action) {
                    response.status(404).send(`action ${key} not found`);
                    return;
                }
                if (stream === "true") {
                    try {
                        const callback = (chunk)=>{
                            response.write(JSON.stringify(chunk) + "\n");
                        };
                        const result = await (0, import_action.runWithStreamingCallback)(this.registry, callback, ()=>action.run(input, {
                                context,
                                onChunk: callback
                            }));
                        await (0, import_tracing.flushTracing)();
                        response.write(JSON.stringify({
                            result: result.result,
                            telemetry: {
                                traceId: result.telemetry.traceId
                            }
                        }));
                        response.end();
                    } catch (err) {
                        const { message, stack } = err;
                        const errorResponse = {
                            code: import_action.StatusCodes.INTERNAL,
                            message,
                            details: {
                                stack
                            }
                        };
                        if (err.traceId) {
                            errorResponse.details.traceId = err.traceId;
                        }
                        response.write(JSON.stringify({
                            error: errorResponse
                        }));
                        response.end();
                    }
                } else {
                    const result = await action.run(input, {
                        context,
                        telemetryLabels
                    });
                    await (0, import_tracing.flushTracing)();
                    response.send({
                        result: result.result,
                        telemetry: {
                            traceId: result.telemetry.traceId
                        }
                    });
                }
            } catch (err) {
                const { message, stack, traceId } = err;
                next({
                    message,
                    stack,
                    traceId
                });
            }
        });
        server.get("/api/envs", async (_, response)=>{
            response.json(this.options.configuredEnvs);
        });
        server.post("/api/notify", async (request, response)=>{
            const { telemetryServerUrl, reflectionApiSpecVersion } = request.body;
            if (!process.env.GENKIT_TELEMETRY_SERVER) {
                if (typeof telemetryServerUrl === "string") {
                    (0, import_tracing.setTelemetryServerUrl)(telemetryServerUrl);
                    import_logging.logger.debug(`Connected to telemetry server on ${telemetryServerUrl}`);
                }
            }
            if (reflectionApiSpecVersion !== import_index.GENKIT_REFLECTION_API_SPEC_VERSION) {
                if (!reflectionApiSpecVersion || reflectionApiSpecVersion < import_index.GENKIT_REFLECTION_API_SPEC_VERSION) {
                    import_logging.logger.warn("WARNING: Genkit CLI version may be outdated. Please update `genkit-cli` to the latest version.");
                } else {
                    import_logging.logger.warn(`Genkit CLI is newer than runtime library. Some feature may not be supported. Consider upgrading your runtime library version (debug info: expected ${import_index.GENKIT_REFLECTION_API_SPEC_VERSION}, got ${reflectionApiSpecVersion}).`);
                }
            }
            response.status(200).send("OK");
        });
        server.use((err, req, res, next)=>{
            import_logging.logger.error(err.stack);
            const error = err;
            const { message, stack } = error;
            const errorResponse = {
                code: import_action.StatusCodes.INTERNAL,
                message,
                details: {
                    stack
                }
            };
            if (err.traceId) {
                errorResponse.details.traceId = err.traceId;
            }
            res.status(500).json(errorResponse);
        });
        this.port = await this.findPort();
        this.server = server.listen(this.port, async ()=>{
            import_logging.logger.debug(`Reflection server (${process.pid}) running on http://localhost:${this.port}`);
            ReflectionServer.RUNNING_SERVERS.push(this);
            await this.writeRuntimeFile();
        });
    }
    /**
   * Stops the server and removes it from the list of running servers to clean up on exit.
   */ async stop() {
        if (!this.server) {
            return;
        }
        return new Promise(async (resolve, reject)=>{
            await this.cleanupRuntimeFile();
            this.server.close(async (err)=>{
                if (err) {
                    import_logging.logger.error(`Error shutting down reflection server on port ${this.port}: ${err}`);
                    reject(err);
                }
                const index = ReflectionServer.RUNNING_SERVERS.indexOf(this);
                if (index > -1) {
                    ReflectionServer.RUNNING_SERVERS.splice(index, 1);
                }
                import_logging.logger.debug(`Reflection server on port ${this.port} has successfully shut down.`);
                this.port = null;
                this.server = null;
                resolve();
            });
        });
    }
    /**
   * Writes the runtime file to the project root.
   */ async writeRuntimeFile() {
        try {
            const rootDir = await findProjectRoot();
            const runtimesDir = import_path.default.join(rootDir, ".genkit", "runtimes");
            const date = /* @__PURE__ */ new Date();
            const time = date.getTime();
            const timestamp = date.toISOString();
            this.runtimeFilePath = import_path.default.join(runtimesDir, `${process.pid}-${time}.json`);
            const fileContent = JSON.stringify({
                id: process.env.GENKIT_RUNTIME_ID || process.pid.toString(),
                pid: process.pid,
                reflectionServerUrl: `http://localhost:${this.port}`,
                timestamp,
                genkitVersion: `nodejs/${import_index.GENKIT_VERSION}`,
                reflectionApiSpecVersion: import_index.GENKIT_REFLECTION_API_SPEC_VERSION
            }, null, 2);
            await import_promises.default.mkdir(runtimesDir, {
                recursive: true
            });
            await import_promises.default.writeFile(this.runtimeFilePath, fileContent, "utf8");
            import_logging.logger.debug(`Runtime file written: ${this.runtimeFilePath}`);
        } catch (error) {
            import_logging.logger.error(`Error writing runtime file: ${error}`);
        }
    }
    /**
   * Cleans up the port file.
   */ async cleanupRuntimeFile() {
        if (!this.runtimeFilePath) {
            return;
        }
        try {
            const fileContent = await import_promises.default.readFile(this.runtimeFilePath, "utf8");
            const data = JSON.parse(fileContent);
            if (data.pid === process.pid) {
                await import_promises.default.unlink(this.runtimeFilePath);
                import_logging.logger.debug(`Runtime file cleaned up: ${this.runtimeFilePath}`);
            }
        } catch (error) {
            import_logging.logger.error(`Error cleaning up runtime file: ${error}`);
        }
    }
    /**
   * Stops all running reflection servers.
   */ static async stopAll() {
        return Promise.all(ReflectionServer.RUNNING_SERVERS.map((server)=>server.stop()));
    }
}
async function findProjectRoot() {
    let currentDir = process.cwd();
    while(currentDir !== import_path.default.parse(currentDir).root){
        const packageJsonPath = import_path.default.join(currentDir, "package.json");
        try {
            await import_promises.default.access(packageJsonPath);
            return currentDir;
        } catch  {
            currentDir = import_path.default.dirname(currentDir);
        }
    }
    throw new Error("Could not find project root (package.json not found)");
}
if (("TURBOPACK compile-time value", "object") !== "undefined" && "hot" in module) {
    module.hot.accept();
    module.hot.dispose(async ()=>{
        import_logging.logger.debug("Cleaning up reflection server(s) before module reload...");
        await ReflectionServer.stopAll();
    });
}
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
    ReflectionServer,
    RunActionResponseSchema
}); //# sourceMappingURL=reflection.js.map
}}),
"[project]/node_modules/@genkit-ai/core/lib/telemetryTypes.js [app-rsc] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __copyProps = (to, from, except, desc)=>{
    if (from && typeof from === "object" || typeof from === "function") {
        for (let key of __getOwnPropNames(from))if (!__hasOwnProp.call(to, key) && key !== except) __defProp(to, key, {
            get: ()=>from[key],
            enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable
        });
    }
    return to;
};
var __toCommonJS = (mod)=>__copyProps(__defProp({}, "__esModule", {
        value: true
    }), mod);
var telemetryTypes_exports = {};
module.exports = __toCommonJS(telemetryTypes_exports); //# sourceMappingURL=telemetryTypes.js.map
}}),
"[project]/node_modules/@genkit-ai/core/lib/index.js [app-rsc] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all)=>{
    for(var name in all)__defProp(target, name, {
        get: all[name],
        enumerable: true
    });
};
var __copyProps = (to, from, except, desc)=>{
    if (from && typeof from === "object" || typeof from === "function") {
        for (let key of __getOwnPropNames(from))if (!__hasOwnProp.call(to, key) && key !== except) __defProp(to, key, {
            get: ()=>from[key],
            enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable
        });
    }
    return to;
};
var __reExport = (target, mod, secondTarget)=>(__copyProps(target, mod, "default"), secondTarget && __copyProps(secondTarget, mod, "default"));
var __toCommonJS = (mod)=>__copyProps(__defProp({}, "__esModule", {
        value: true
    }), mod);
var src_exports = {};
__export(src_exports, {
    GENKIT_CLIENT_HEADER: ()=>GENKIT_CLIENT_HEADER,
    GENKIT_REFLECTION_API_SPEC_VERSION: ()=>GENKIT_REFLECTION_API_SPEC_VERSION,
    GENKIT_VERSION: ()=>GENKIT_VERSION,
    GenkitError: ()=>import_error.GenkitError,
    UnstableApiError: ()=>import_error.UnstableApiError,
    UserFacingError: ()=>import_error.UserFacingError,
    apiKey: ()=>import_context.apiKey,
    assertUnstable: ()=>import_error.assertUnstable,
    defineFlow: ()=>import_flow.defineFlow,
    defineJsonSchema: ()=>import_schema.defineJsonSchema,
    defineSchema: ()=>import_schema.defineSchema,
    getCallableJSON: ()=>import_error.getCallableJSON,
    getContext: ()=>import_context.getContext,
    getHttpStatus: ()=>import_error.getHttpStatus,
    run: ()=>import_flow.run,
    runWithContext: ()=>import_context.runWithContext,
    z: ()=>import_zod.z
});
module.exports = __toCommonJS(src_exports);
var import_version = __turbopack_context__.r("[project]/node_modules/@genkit-ai/core/lib/__codegen/version.js [app-rsc] (ecmascript)");
var import_zod = __turbopack_context__.r("[project]/node_modules/zod/lib/index.js [app-rsc] (ecmascript)");
__reExport(src_exports, __turbopack_context__.r("[project]/node_modules/@genkit-ai/core/lib/action.js [app-rsc] (ecmascript)"), module.exports);
var import_context = __turbopack_context__.r("[project]/node_modules/@genkit-ai/core/lib/context.js [app-rsc] (ecmascript)");
var import_error = __turbopack_context__.r("[project]/node_modules/@genkit-ai/core/lib/error.js [app-rsc] (ecmascript)");
var import_flow = __turbopack_context__.r("[project]/node_modules/@genkit-ai/core/lib/flow.js [app-rsc] (ecmascript)");
__reExport(src_exports, __turbopack_context__.r("[project]/node_modules/@genkit-ai/core/lib/plugin.js [app-rsc] (ecmascript)"), module.exports);
__reExport(src_exports, __turbopack_context__.r("[project]/node_modules/@genkit-ai/core/lib/reflection.js [app-rsc] (ecmascript)"), module.exports);
var import_schema = __turbopack_context__.r("[project]/node_modules/@genkit-ai/core/lib/schema.js [app-rsc] (ecmascript)");
__reExport(src_exports, __turbopack_context__.r("[project]/node_modules/@genkit-ai/core/lib/telemetryTypes.js [app-rsc] (ecmascript)"), module.exports);
__reExport(src_exports, __turbopack_context__.r("[project]/node_modules/@genkit-ai/core/lib/utils.js [app-rsc] (ecmascript)"), module.exports);
const GENKIT_VERSION = import_version.version;
const GENKIT_CLIENT_HEADER = `genkit-node/${GENKIT_VERSION} gl-node/${process.versions.node}`;
const GENKIT_REFLECTION_API_SPEC_VERSION = 1;
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
    GENKIT_CLIENT_HEADER,
    GENKIT_REFLECTION_API_SPEC_VERSION,
    GENKIT_VERSION,
    GenkitError,
    UnstableApiError,
    UserFacingError,
    apiKey,
    assertUnstable,
    defineFlow,
    defineJsonSchema,
    defineSchema,
    getCallableJSON,
    getContext,
    getHttpStatus,
    run,
    runWithContext,
    z,
    ...__turbopack_context__.r("[project]/node_modules/@genkit-ai/core/lib/action.js [app-rsc] (ecmascript)"),
    ...__turbopack_context__.r("[project]/node_modules/@genkit-ai/core/lib/plugin.js [app-rsc] (ecmascript)"),
    ...__turbopack_context__.r("[project]/node_modules/@genkit-ai/core/lib/reflection.js [app-rsc] (ecmascript)"),
    ...__turbopack_context__.r("[project]/node_modules/@genkit-ai/core/lib/telemetryTypes.js [app-rsc] (ecmascript)"),
    ...__turbopack_context__.r("[project]/node_modules/@genkit-ai/core/lib/utils.js [app-rsc] (ecmascript)")
}); //# sourceMappingURL=index.js.map
}}),
"[project]/node_modules/@genkit-ai/googleai/lib/embedder.js [app-rsc] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all)=>{
    for(var name in all)__defProp(target, name, {
        get: all[name],
        enumerable: true
    });
};
var __copyProps = (to, from, except, desc)=>{
    if (from && typeof from === "object" || typeof from === "function") {
        for (let key of __getOwnPropNames(from))if (!__hasOwnProp.call(to, key) && key !== except) __defProp(to, key, {
            get: ()=>from[key],
            enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable
        });
    }
    return to;
};
var __toCommonJS = (mod)=>__copyProps(__defProp({}, "__esModule", {
        value: true
    }), mod);
var embedder_exports = {};
__export(embedder_exports, {
    GeminiEmbeddingConfigSchema: ()=>GeminiEmbeddingConfigSchema,
    SUPPORTED_MODELS: ()=>SUPPORTED_MODELS,
    TaskTypeSchema: ()=>TaskTypeSchema,
    defineGoogleAIEmbedder: ()=>defineGoogleAIEmbedder,
    textEmbedding004: ()=>textEmbedding004,
    textEmbeddingGecko001: ()=>textEmbeddingGecko001
});
module.exports = __toCommonJS(embedder_exports);
var import_generative_ai = __turbopack_context__.r("[project]/node_modules/@google/generative-ai/dist/index.js [app-rsc] (ecmascript)");
var import_genkit = __turbopack_context__.r("[project]/node_modules/genkit/lib/index.js [app-rsc] (ecmascript)");
var import_embedder = __turbopack_context__.r("[project]/node_modules/genkit/lib/embedder.js [app-rsc] (ecmascript)");
const TaskTypeSchema = import_genkit.z.enum([
    "RETRIEVAL_DOCUMENT",
    "RETRIEVAL_QUERY",
    "SEMANTIC_SIMILARITY",
    "CLASSIFICATION",
    "CLUSTERING"
]);
const GeminiEmbeddingConfigSchema = import_genkit.z.object({
    /**
   * The `task_type` parameter is defined as the intended downstream application to help the model
   * produce better quality embeddings.
   **/ taskType: TaskTypeSchema.optional(),
    title: import_genkit.z.string().optional(),
    version: import_genkit.z.string().optional(),
    /**
   * The `outputDimensionality` parameter allows you to specify the dimensionality of the embedding output.
   * By default, the model generates embeddings with 768 dimensions. Models such as
   * `text-embedding-004`, `text-embedding-005`, and `text-multilingual-embedding-002`
   * allow the output dimensionality to be adjusted between 1 and 768.
   * By selecting a smaller output dimensionality, users can save memory and storage space, leading to more efficient computations.
   **/ outputDimensionality: import_genkit.z.number().min(1).max(768).optional()
});
const textEmbeddingGecko001 = (0, import_embedder.embedderRef)({
    name: "googleai/embedding-001",
    configSchema: GeminiEmbeddingConfigSchema,
    info: {
        dimensions: 768,
        label: "Google Gen AI - Text Embedding Gecko (Legacy)",
        supports: {
            input: [
                "text"
            ]
        }
    }
});
const textEmbedding004 = (0, import_embedder.embedderRef)({
    name: "googleai/text-embedding-004",
    configSchema: GeminiEmbeddingConfigSchema,
    info: {
        dimensions: 768,
        label: "Google Gen AI - Text Embedding 001",
        supports: {
            input: [
                "text"
            ]
        }
    }
});
const SUPPORTED_MODELS = {
    "embedding-001": textEmbeddingGecko001,
    "text-embedding-004": textEmbedding004
};
function defineGoogleAIEmbedder(ai, name, options) {
    let apiKey = options?.apiKey || process.env.GOOGLE_GENAI_API_KEY || process.env.GOOGLE_API_KEY;
    if (!apiKey) throw new Error("Please pass in the API key or set either GOOGLE_GENAI_API_KEY or GOOGLE_API_KEY environment variable.\nFor more details see https://firebase.google.com/docs/genkit/plugins/google-genai");
    const embedder = SUPPORTED_MODELS[name] ?? (0, import_embedder.embedderRef)({
        name,
        configSchema: GeminiEmbeddingConfigSchema,
        info: {
            dimensions: 768,
            label: `Google AI - ${name}`,
            supports: {
                input: [
                    "text"
                ]
            }
        }
    });
    const apiModelName = embedder.name.startsWith("googleai/") ? embedder.name.substring("googleai/".length) : embedder.name;
    return ai.defineEmbedder({
        name: embedder.name,
        configSchema: GeminiEmbeddingConfigSchema,
        info: embedder.info
    }, async (input, options2)=>{
        const client = new import_generative_ai.GoogleGenerativeAI(apiKey).getGenerativeModel({
            model: options2?.version || embedder.config?.version || embedder.version || apiModelName
        });
        const embeddings = await Promise.all(input.map(async (doc)=>{
            const response = await client.embedContent({
                taskType: options2?.taskType,
                title: options2?.title,
                content: {
                    role: "",
                    parts: [
                        {
                            text: doc.text
                        }
                    ]
                },
                outputDimensionality: options2?.outputDimensionality
            });
            const values = response.embedding.values;
            return {
                embedding: values
            };
        }));
        return {
            embeddings
        };
    });
}
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
    GeminiEmbeddingConfigSchema,
    SUPPORTED_MODELS,
    TaskTypeSchema,
    defineGoogleAIEmbedder,
    textEmbedding004,
    textEmbeddingGecko001
}); //# sourceMappingURL=embedder.js.map
}}),
"[project]/node_modules/@genkit-ai/googleai/lib/context-caching/constants.js [app-rsc] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all)=>{
    for(var name in all)__defProp(target, name, {
        get: all[name],
        enumerable: true
    });
};
var __copyProps = (to, from, except, desc)=>{
    if (from && typeof from === "object" || typeof from === "function") {
        for (let key of __getOwnPropNames(from))if (!__hasOwnProp.call(to, key) && key !== except) __defProp(to, key, {
            get: ()=>from[key],
            enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable
        });
    }
    return to;
};
var __toCommonJS = (mod)=>__copyProps(__defProp({}, "__esModule", {
        value: true
    }), mod);
var constants_exports = {};
__export(constants_exports, {
    CONTEXT_CACHE_SUPPORTED_MODELS: ()=>CONTEXT_CACHE_SUPPORTED_MODELS,
    DEFAULT_TTL: ()=>DEFAULT_TTL,
    INVALID_ARGUMENT_MESSAGES: ()=>INVALID_ARGUMENT_MESSAGES
});
module.exports = __toCommonJS(constants_exports);
const CONTEXT_CACHE_SUPPORTED_MODELS = [
    "gemini-1.5-flash-001",
    "gemini-1.5-pro-001"
];
const INVALID_ARGUMENT_MESSAGES = {
    modelVersion: `Model version is required for context caching, supported only in ${CONTEXT_CACHE_SUPPORTED_MODELS.join(",")} models.`,
    tools: "Context caching cannot be used simultaneously with tools.",
    codeExecution: "Context caching cannot be used simultaneously with code execution."
};
const DEFAULT_TTL = 300;
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
    CONTEXT_CACHE_SUPPORTED_MODELS,
    DEFAULT_TTL,
    INVALID_ARGUMENT_MESSAGES
}); //# sourceMappingURL=constants.js.map
}}),
"[project]/node_modules/@genkit-ai/googleai/lib/context-caching/types.js [app-rsc] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all)=>{
    for(var name in all)__defProp(target, name, {
        get: all[name],
        enumerable: true
    });
};
var __copyProps = (to, from, except, desc)=>{
    if (from && typeof from === "object" || typeof from === "function") {
        for (let key of __getOwnPropNames(from))if (!__hasOwnProp.call(to, key) && key !== except) __defProp(to, key, {
            get: ()=>from[key],
            enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable
        });
    }
    return to;
};
var __toCommonJS = (mod)=>__copyProps(__defProp({}, "__esModule", {
        value: true
    }), mod);
var types_exports = {};
__export(types_exports, {
    cacheConfigDetailsSchema: ()=>cacheConfigDetailsSchema,
    cacheConfigSchema: ()=>cacheConfigSchema
});
module.exports = __toCommonJS(types_exports);
var import_genkit = __turbopack_context__.r("[project]/node_modules/genkit/lib/index.js [app-rsc] (ecmascript)");
const cacheConfigSchema = import_genkit.z.union([
    import_genkit.z.boolean(),
    import_genkit.z.object({
        ttlSeconds: import_genkit.z.number().optional()
    }).passthrough()
]);
const cacheConfigDetailsSchema = import_genkit.z.object({
    cacheConfig: cacheConfigSchema,
    endOfCachedContents: import_genkit.z.number()
});
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
    cacheConfigDetailsSchema,
    cacheConfigSchema
}); //# sourceMappingURL=types.js.map
}}),
"[project]/node_modules/@genkit-ai/googleai/lib/context-caching/utils.js [app-rsc] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all)=>{
    for(var name in all)__defProp(target, name, {
        get: all[name],
        enumerable: true
    });
};
var __copyProps = (to, from, except, desc)=>{
    if (from && typeof from === "object" || typeof from === "function") {
        for (let key of __getOwnPropNames(from))if (!__hasOwnProp.call(to, key) && key !== except) __defProp(to, key, {
            get: ()=>from[key],
            enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable
        });
    }
    return to;
};
var __toESM = (mod, isNodeMode, target)=>(target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(// If the importer is in node compatibility mode or this is not an ESM
    // file that has been converted to a CommonJS file using a Babel-
    // compatible transform (i.e. "__esModule" has not been set), then set
    // "default" to the CommonJS "module.exports" for node compatibility.
    isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", {
        value: mod,
        enumerable: true
    }) : target, mod));
var __toCommonJS = (mod)=>__copyProps(__defProp({}, "__esModule", {
        value: true
    }), mod);
var utils_exports = {};
__export(utils_exports, {
    calculateTTL: ()=>calculateTTL,
    extractCacheConfig: ()=>extractCacheConfig,
    findLastIndex: ()=>findLastIndex,
    generateCacheKey: ()=>generateCacheKey,
    getContentForCache: ()=>getContentForCache,
    lookupContextCache: ()=>lookupContextCache,
    validateContextCacheRequest: ()=>validateContextCacheRequest
});
module.exports = __toCommonJS(utils_exports);
var import_crypto = __toESM(__turbopack_context__.r("[externals]/crypto [external] (crypto, cjs)"));
var import_genkit = __turbopack_context__.r("[project]/node_modules/genkit/lib/index.js [app-rsc] (ecmascript)");
var import_constants = __turbopack_context__.r("[project]/node_modules/@genkit-ai/googleai/lib/context-caching/constants.js [app-rsc] (ecmascript)");
var import_types = __turbopack_context__.r("[project]/node_modules/@genkit-ai/googleai/lib/context-caching/types.js [app-rsc] (ecmascript)");
function generateCacheKey(request) {
    return import_crypto.default.createHash("sha256").update(JSON.stringify(request)).digest("hex");
}
function getContentForCache(request, chatRequest, modelVersion, cacheConfigDetails) {
    if (!modelVersion) {
        throw new Error("No model version provided for context caching");
    }
    if (!chatRequest.history?.length) {
        throw new Error("No history provided for context caching");
    }
    validateHistoryLength(request, chatRequest);
    const { endOfCachedContents, cacheConfig } = cacheConfigDetails;
    const cachedContent = {
        model: modelVersion,
        contents: chatRequest.history.slice(0, endOfCachedContents + 1)
    };
    chatRequest.history = chatRequest.history.slice(endOfCachedContents + 1);
    return {
        cachedContent,
        chatRequest,
        cacheConfig
    };
}
function validateHistoryLength(request, chatRequest) {
    if (chatRequest.history?.length !== request.messages.length - 1) {
        throw new import_genkit.GenkitError({
            status: "INTERNAL",
            message: "Genkit request history and Gemini chat request history length do not match"
        });
    }
}
async function lookupContextCache(cacheManager, cacheKey, maxPages = 100, pageSize = 100) {
    let currentPage = 0;
    let pageToken;
    try {
        while(currentPage < maxPages){
            const { cachedContents, nextPageToken } = await cacheManager.list({
                pageSize,
                pageToken
            });
            const found = cachedContents?.find((content)=>content.displayName === cacheKey);
            if (found) return found;
            if (!nextPageToken) break;
            pageToken = nextPageToken;
            currentPage++;
        }
    } catch (error) {
        const message = error instanceof Error ? error.message : "Unknown Network Error";
        throw new import_genkit.GenkitError({
            status: "INTERNAL",
            message: `Error looking up context cache: ${message}`
        });
    }
    return null;
}
const extractCacheConfig = (request)=>{
    const endOfCachedContents = findLastIndex(request.messages, (message)=>!!message.metadata?.cache);
    return endOfCachedContents === -1 ? null : {
        endOfCachedContents,
        cacheConfig: import_types.cacheConfigSchema.parse(request.messages[endOfCachedContents].metadata?.cache)
    };
};
function validateContextCacheRequest(request, modelVersion) {
    if (!modelVersion || !import_constants.CONTEXT_CACHE_SUPPORTED_MODELS.includes(modelVersion)) {
        throw new import_genkit.GenkitError({
            status: "INVALID_ARGUMENT",
            message: import_constants.INVALID_ARGUMENT_MESSAGES.modelVersion
        });
    }
    if (request.tools?.length) throw new import_genkit.GenkitError({
        status: "INVALID_ARGUMENT",
        message: import_constants.INVALID_ARGUMENT_MESSAGES.tools
    });
    if (request.config?.codeExecution) throw new import_genkit.GenkitError({
        status: "INVALID_ARGUMENT",
        message: import_constants.INVALID_ARGUMENT_MESSAGES.codeExecution
    });
    return true;
}
function findLastIndex(array, callback) {
    for(let i = array.length - 1; i >= 0; i--){
        if (callback(array[i], i, array)) return i;
    }
    return -1;
}
function calculateTTL(cacheConfig) {
    if (cacheConfig.cacheConfig === true) {
        return import_constants.DEFAULT_TTL;
    }
    if (cacheConfig.cacheConfig === false) {
        return 0;
    }
    return cacheConfig.cacheConfig.ttlSeconds || import_constants.DEFAULT_TTL;
}
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
    calculateTTL,
    extractCacheConfig,
    findLastIndex,
    generateCacheKey,
    getContentForCache,
    lookupContextCache,
    validateContextCacheRequest
}); //# sourceMappingURL=utils.js.map
}}),
"[project]/node_modules/@genkit-ai/googleai/lib/context-caching/index.js [app-rsc] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all)=>{
    for(var name in all)__defProp(target, name, {
        get: all[name],
        enumerable: true
    });
};
var __copyProps = (to, from, except, desc)=>{
    if (from && typeof from === "object" || typeof from === "function") {
        for (let key of __getOwnPropNames(from))if (!__hasOwnProp.call(to, key) && key !== except) __defProp(to, key, {
            get: ()=>from[key],
            enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable
        });
    }
    return to;
};
var __toCommonJS = (mod)=>__copyProps(__defProp({}, "__esModule", {
        value: true
    }), mod);
var context_caching_exports = {};
__export(context_caching_exports, {
    handleCacheIfNeeded: ()=>handleCacheIfNeeded,
    handleContextCache: ()=>handleContextCache
});
module.exports = __toCommonJS(context_caching_exports);
var import_server = __turbopack_context__.r("[project]/node_modules/@google/generative-ai/dist/server/index.js [app-rsc] (ecmascript)");
var import_genkit = __turbopack_context__.r("[project]/node_modules/genkit/lib/index.js [app-rsc] (ecmascript)");
var import_logging = __turbopack_context__.r("[project]/node_modules/genkit/lib/logging.js [app-rsc] (ecmascript)");
var import_utils = __turbopack_context__.r("[project]/node_modules/@genkit-ai/googleai/lib/context-caching/utils.js [app-rsc] (ecmascript)");
async function handleContextCache(apiKey, request, chatRequest, modelVersion, cacheConfigDetails) {
    const cacheManager = new import_server.GoogleAICacheManager(apiKey);
    const { cachedContent, chatRequest: newChatRequest } = (0, import_utils.getContentForCache)(request, chatRequest, modelVersion, cacheConfigDetails);
    cachedContent.model = modelVersion;
    const cacheKey = (0, import_utils.generateCacheKey)(cachedContent);
    cachedContent.displayName = cacheKey;
    let cache = await (0, import_utils.lookupContextCache)(cacheManager, cacheKey);
    import_logging.logger.debug(`Cache hit: ${cache ? "true" : "false"}`);
    if (!cache) {
        try {
            import_logging.logger.debug("No cache found, creating one.");
            const createParams = {
                ...cachedContent,
                ttlSeconds: (0, import_utils.calculateTTL)(cacheConfigDetails)
            };
            cache = await cacheManager.create(createParams);
            import_logging.logger.debug(`Created new cache entry with key: ${cacheKey}`);
        } catch (cacheError) {
            import_logging.logger.error(`Failed to create cache with key ${cacheKey}: ${cacheError}`);
            throw new import_genkit.GenkitError({
                status: "INTERNAL",
                message: `Failed to create cache: ${cacheError}`
            });
        }
    }
    if (!cache) {
        throw new import_genkit.GenkitError({
            status: "INTERNAL",
            message: "Failed to use context cache feature"
        });
    }
    return {
        cache,
        newChatRequest
    };
}
async function handleCacheIfNeeded(apiKey, request, chatRequest, modelVersion, cacheConfigDetails) {
    if (!cacheConfigDetails || !(0, import_utils.validateContextCacheRequest)(request, modelVersion)) {
        return {
            chatRequest,
            cache: null
        };
    }
    const { cache, newChatRequest } = await handleContextCache(apiKey, request, chatRequest, modelVersion, cacheConfigDetails);
    return {
        chatRequest: newChatRequest,
        cache
    };
}
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
    handleCacheIfNeeded,
    handleContextCache
}); //# sourceMappingURL=index.js.map
}}),
"[project]/node_modules/@genkit-ai/googleai/lib/gemini.js [app-rsc] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all)=>{
    for(var name in all)__defProp(target, name, {
        get: all[name],
        enumerable: true
    });
};
var __copyProps = (to, from, except, desc)=>{
    if (from && typeof from === "object" || typeof from === "function") {
        for (let key of __getOwnPropNames(from))if (!__hasOwnProp.call(to, key) && key !== except) __defProp(to, key, {
            get: ()=>from[key],
            enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable
        });
    }
    return to;
};
var __toESM = (mod, isNodeMode, target)=>(target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(// If the importer is in node compatibility mode or this is not an ESM
    // file that has been converted to a CommonJS file using a Babel-
    // compatible transform (i.e. "__esModule" has not been set), then set
    // "default" to the CommonJS "module.exports" for node compatibility.
    isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", {
        value: mod,
        enumerable: true
    }) : target, mod));
var __toCommonJS = (mod)=>__copyProps(__defProp({}, "__esModule", {
        value: true
    }), mod);
var gemini_exports = {};
__export(gemini_exports, {
    GENERIC_GEMINI_MODEL: ()=>GENERIC_GEMINI_MODEL,
    GeminiConfigSchema: ()=>GeminiConfigSchema,
    SUPPORTED_GEMINI_MODELS: ()=>SUPPORTED_GEMINI_MODELS,
    SUPPORTED_V15_MODELS: ()=>SUPPORTED_V15_MODELS,
    SUPPORTED_V1_MODELS: ()=>SUPPORTED_V1_MODELS,
    cleanSchema: ()=>cleanSchema,
    defineGoogleAIModel: ()=>defineGoogleAIModel,
    fromGeminiCandidate: ()=>fromGeminiCandidate,
    gemini: ()=>gemini,
    gemini10Pro: ()=>gemini10Pro,
    gemini15Flash: ()=>gemini15Flash,
    gemini15Flash8b: ()=>gemini15Flash8b,
    gemini15Pro: ()=>gemini15Pro,
    gemini20Flash: ()=>gemini20Flash,
    toGeminiMessage: ()=>toGeminiMessage,
    toGeminiSystemInstruction: ()=>toGeminiSystemInstruction
});
module.exports = __toCommonJS(gemini_exports);
var import_generative_ai = __turbopack_context__.r("[project]/node_modules/@google/generative-ai/dist/index.js [app-rsc] (ecmascript)");
var import_genkit = __turbopack_context__.r("[project]/node_modules/genkit/lib/index.js [app-rsc] (ecmascript)");
var import_model = __turbopack_context__.r("[project]/node_modules/genkit/lib/model.js [app-rsc] (ecmascript)");
var import_middleware = __turbopack_context__.r("[project]/node_modules/genkit/lib/middleware.js [app-rsc] (ecmascript)");
var import_process = __toESM(__turbopack_context__.r("[externals]/process [external] (process, cjs)"));
var import_context_caching = __turbopack_context__.r("[project]/node_modules/@genkit-ai/googleai/lib/context-caching/index.js [app-rsc] (ecmascript)");
var import_utils = __turbopack_context__.r("[project]/node_modules/@genkit-ai/googleai/lib/context-caching/utils.js [app-rsc] (ecmascript)");
const SafetySettingsSchema = import_genkit.z.object({
    category: import_genkit.z.enum([
        "HARM_CATEGORY_UNSPECIFIED",
        "HARM_CATEGORY_HATE_SPEECH",
        "HARM_CATEGORY_SEXUALLY_EXPLICIT",
        "HARM_CATEGORY_HARASSMENT",
        "HARM_CATEGORY_DANGEROUS_CONTENT"
    ]),
    threshold: import_genkit.z.enum([
        "BLOCK_LOW_AND_ABOVE",
        "BLOCK_MEDIUM_AND_ABOVE",
        "BLOCK_ONLY_HIGH",
        "BLOCK_NONE"
    ])
});
const GeminiConfigSchema = import_model.GenerationCommonConfigSchema.extend({
    safetySettings: import_genkit.z.array(SafetySettingsSchema).optional(),
    codeExecution: import_genkit.z.union([
        import_genkit.z.boolean(),
        import_genkit.z.object({}).strict()
    ]).optional(),
    contextCache: import_genkit.z.boolean().optional(),
    functionCallingConfig: import_genkit.z.object({
        mode: import_genkit.z.enum([
            "MODE_UNSPECIFIED",
            "AUTO",
            "ANY",
            "NONE"
        ]).optional(),
        allowedFunctionNames: import_genkit.z.array(import_genkit.z.string()).optional()
    }).optional()
});
const gemini10Pro = (0, import_model.modelRef)({
    name: "googleai/gemini-1.0-pro",
    info: {
        label: "Google AI - Gemini Pro",
        versions: [
            "gemini-pro",
            "gemini-1.0-pro-latest",
            "gemini-1.0-pro-001"
        ],
        supports: {
            multiturn: true,
            media: false,
            tools: true,
            toolChoice: true,
            systemRole: true,
            constrained: "no-tools"
        }
    },
    configSchema: GeminiConfigSchema
});
const gemini15Pro = (0, import_model.modelRef)({
    name: "googleai/gemini-1.5-pro",
    info: {
        label: "Google AI - Gemini 1.5 Pro",
        supports: {
            multiturn: true,
            media: true,
            tools: true,
            toolChoice: true,
            systemRole: true,
            constrained: "no-tools"
        },
        versions: [
            "gemini-1.5-pro-latest",
            "gemini-1.5-pro-001",
            "gemini-1.5-pro-002"
        ]
    },
    configSchema: GeminiConfigSchema
});
const gemini15Flash = (0, import_model.modelRef)({
    name: "googleai/gemini-1.5-flash",
    info: {
        label: "Google AI - Gemini 1.5 Flash",
        supports: {
            multiturn: true,
            media: true,
            tools: true,
            toolChoice: true,
            systemRole: true,
            constrained: "no-tools",
            // @ts-ignore
            contextCache: true
        },
        versions: [
            "gemini-1.5-flash-latest",
            "gemini-1.5-flash-001",
            "gemini-1.5-flash-002"
        ]
    },
    configSchema: GeminiConfigSchema
});
const gemini15Flash8b = (0, import_model.modelRef)({
    name: "googleai/gemini-1.5-flash-8b",
    info: {
        label: "Google AI - Gemini 1.5 Flash",
        supports: {
            multiturn: true,
            media: true,
            tools: true,
            toolChoice: true,
            systemRole: true,
            constrained: "no-tools"
        },
        versions: [
            "gemini-1.5-flash-8b-latest",
            "gemini-1.5-flash-8b-001"
        ]
    },
    configSchema: GeminiConfigSchema
});
const gemini20Flash = (0, import_model.modelRef)({
    name: "googleai/gemini-2.0-flash",
    info: {
        label: "Google AI - Gemini 2.0 Flash",
        versions: [],
        supports: {
            multiturn: true,
            media: true,
            tools: true,
            toolChoice: true,
            systemRole: true,
            constrained: "no-tools"
        }
    },
    configSchema: GeminiConfigSchema
});
const SUPPORTED_V1_MODELS = {
    "gemini-1.0-pro": gemini10Pro
};
const SUPPORTED_V15_MODELS = {
    "gemini-1.5-pro": gemini15Pro,
    "gemini-1.5-flash": gemini15Flash,
    "gemini-1.5-flash-8b": gemini15Flash8b,
    "gemini-2.0-flash": gemini20Flash
};
const GENERIC_GEMINI_MODEL = (0, import_model.modelRef)({
    name: "googleai/gemini",
    configSchema: GeminiConfigSchema,
    info: {
        label: "Google Gemini",
        supports: {
            multiturn: true,
            media: true,
            tools: true,
            toolChoice: true,
            systemRole: true,
            constrained: "no-tools"
        }
    }
});
const SUPPORTED_GEMINI_MODELS = {
    ...SUPPORTED_V1_MODELS,
    ...SUPPORTED_V15_MODELS
};
function longestMatchingPrefix(version, potentialMatches) {
    return potentialMatches.filter((p)=>version.startsWith(p)).reduce((longest, current)=>current.length > longest.length ? current : longest, "");
}
function gemini(version, options = {}) {
    const nearestModel = nearestGeminiModelRef(version);
    return (0, import_model.modelRef)({
        name: `googleai/${version}`,
        config: options,
        configSchema: GeminiConfigSchema,
        info: {
            ...nearestModel.info,
            // If exact suffix match for a known model, use its label, otherwise create a new label
            label: nearestModel.name.endsWith(version) ? nearestModel.info?.label : `Google AI - ${version}`
        }
    });
}
function nearestGeminiModelRef(version, options = {}) {
    const matchingKey = longestMatchingPrefix(version, Object.keys(SUPPORTED_GEMINI_MODELS));
    if (matchingKey) {
        return SUPPORTED_GEMINI_MODELS[matchingKey].withConfig({
            ...options,
            version
        });
    }
    return GENERIC_GEMINI_MODEL.withConfig({
        ...options,
        version
    });
}
function toGeminiRole(role, model) {
    switch(role){
        case "user":
            return "user";
        case "model":
            return "model";
        case "system":
            if (model && SUPPORTED_V15_MODELS[model.name]) {
                throw new Error("system role is only supported for a single message in the first position");
            } else {
                throw new Error("system role is not supported");
            }
        case "tool":
            return "function";
        default:
            return "user";
    }
}
function convertSchemaProperty(property) {
    if (!property || !property.type) {
        return null;
    }
    if (property.type === "object") {
        const nestedProperties = {};
        Object.keys(property.properties).forEach((key)=>{
            nestedProperties[key] = convertSchemaProperty(property.properties[key]);
        });
        return {
            type: import_generative_ai.SchemaType.OBJECT,
            properties: nestedProperties,
            required: property.required
        };
    } else if (property.type === "array") {
        return {
            type: import_generative_ai.SchemaType.ARRAY,
            items: convertSchemaProperty(property.items)
        };
    } else {
        return {
            type: import_generative_ai.SchemaType[property.type.toUpperCase()]
        };
    }
}
function toGeminiTool(tool) {
    const declaration = {
        name: tool.name.replace(/\//g, "__"),
        // Gemini throws on '/' in tool name
        description: tool.description,
        parameters: convertSchemaProperty(tool.inputSchema)
    };
    return declaration;
}
function toInlineData(part) {
    const dataUrl = part.media.url;
    const b64Data = dataUrl.substring(dataUrl.indexOf(",") + 1);
    const contentType = part.media.contentType || dataUrl.substring(dataUrl.indexOf(":") + 1, dataUrl.indexOf(";"));
    return {
        inlineData: {
            mimeType: contentType,
            data: b64Data
        }
    };
}
function toFileData(part) {
    if (!part.media.contentType) throw new Error("Must supply a `contentType` when sending File URIs to Gemini.");
    return {
        fileData: {
            mimeType: part.media.contentType,
            fileUri: part.media.url
        }
    };
}
function fromInlineData(inlinePart) {
    if (!inlinePart.inlineData || !inlinePart.inlineData.hasOwnProperty("mimeType") || !inlinePart.inlineData.hasOwnProperty("data")) {
        throw new Error("Invalid InlineDataPart: missing required properties");
    }
    const { mimeType, data } = inlinePart.inlineData;
    const dataUrl = `data:${mimeType};base64,${data}`;
    return {
        media: {
            url: dataUrl,
            contentType: mimeType
        }
    };
}
function toFunctionCall(part) {
    if (!part?.toolRequest?.input) {
        throw Error("Invalid ToolRequestPart: input was missing.");
    }
    return {
        functionCall: {
            name: part.toolRequest.name,
            args: part.toolRequest.input
        }
    };
}
function fromFunctionCall(part) {
    if (!part.functionCall) {
        throw Error("Invalid FunctionCallPart");
    }
    return {
        toolRequest: {
            name: part.functionCall.name,
            input: part.functionCall.args
        }
    };
}
function toFunctionResponse(part) {
    if (!part?.toolResponse?.output) {
        throw Error("Invalid ToolResponsePart: output was missing.");
    }
    return {
        functionResponse: {
            name: part.toolResponse.name,
            response: {
                name: part.toolResponse.name,
                content: part.toolResponse.output
            }
        }
    };
}
function fromFunctionResponse(part) {
    if (!part.functionResponse) {
        throw new Error("Invalid FunctionResponsePart.");
    }
    return {
        toolResponse: {
            name: part.functionResponse.name.replace(/__/g, "/"),
            // restore slashes
            output: part.functionResponse.response
        }
    };
}
function fromExecutableCode(part) {
    if (!part.executableCode) {
        throw new Error("Invalid GeminiPart: missing executableCode");
    }
    return {
        custom: {
            executableCode: {
                language: part.executableCode.language,
                code: part.executableCode.code
            }
        }
    };
}
function fromCodeExecutionResult(part) {
    if (!part.codeExecutionResult) {
        throw new Error("Invalid GeminiPart: missing codeExecutionResult");
    }
    return {
        custom: {
            codeExecutionResult: {
                outcome: part.codeExecutionResult.outcome,
                output: part.codeExecutionResult.output
            }
        }
    };
}
function toCustomPart(part) {
    if (!part.custom) {
        throw new Error("Invalid GeminiPart: missing custom");
    }
    if (part.custom.codeExecutionResult) {
        return {
            codeExecutionResult: part.custom.codeExecutionResult
        };
    }
    if (part.custom.executableCode) {
        return {
            executableCode: part.custom.executableCode
        };
    }
    throw new Error("Unsupported Custom Part type");
}
function toGeminiPart(part) {
    if (part.text !== void 0) return {
        text: part.text || " "
    };
    if (part.media) {
        if (part.media.url.startsWith("data:")) return toInlineData(part);
        return toFileData(part);
    }
    if (part.toolRequest) return toFunctionCall(part);
    if (part.toolResponse) return toFunctionResponse(part);
    if (part.custom) return toCustomPart(part);
    throw new Error("Unsupported Part type" + JSON.stringify(part));
}
function fromGeminiPart(part, jsonMode) {
    if (part.text !== void 0) return {
        text: part.text
    };
    if (part.inlineData) return fromInlineData(part);
    if (part.functionCall) return fromFunctionCall(part);
    if (part.functionResponse) return fromFunctionResponse(part);
    if (part.executableCode) return fromExecutableCode(part);
    if (part.codeExecutionResult) return fromCodeExecutionResult(part);
    throw new Error("Unsupported GeminiPart type");
}
function toGeminiMessage(message, model) {
    return {
        role: toGeminiRole(message.role, model),
        parts: message.content.map(toGeminiPart)
    };
}
function toGeminiSystemInstruction(message) {
    return {
        role: "user",
        parts: message.content.map(toGeminiPart)
    };
}
function fromGeminiFinishReason(reason) {
    if (!reason) return "unknown";
    switch(reason){
        case "STOP":
            return "stop";
        case "MAX_TOKENS":
            return "length";
        case "SAFETY":
        // blocked for safety
        case "RECITATION":
            return "blocked";
        default:
            return "unknown";
    }
}
function fromGeminiCandidate(candidate, jsonMode = false) {
    return {
        index: candidate.index || 0,
        // reasonable default?
        message: {
            role: "model",
            content: (candidate.content?.parts || []).map((part)=>fromGeminiPart(part, jsonMode))
        },
        finishReason: fromGeminiFinishReason(candidate.finishReason),
        finishMessage: candidate.finishMessage,
        custom: {
            safetyRatings: candidate.safetyRatings,
            citationMetadata: candidate.citationMetadata
        }
    };
}
function cleanSchema(schema) {
    const out = structuredClone(schema);
    for(const key in out){
        if (key === "$schema" || key === "additionalProperties") {
            delete out[key];
            continue;
        }
        if (typeof out[key] === "object") {
            out[key] = cleanSchema(out[key]);
        }
        if (key === "type" && Array.isArray(out[key])) {
            out[key] = out[key].find((t)=>t !== "null");
        }
    }
    return out;
}
function defineGoogleAIModel(ai, name, apiKey, apiVersion, baseUrl, info, defaultConfig) {
    if (!apiKey) {
        apiKey = import_process.default.env.GOOGLE_GENAI_API_KEY || import_process.default.env.GOOGLE_API_KEY;
    }
    if (!apiKey) {
        throw new Error("Please pass in the API key or set the GOOGLE_GENAI_API_KEY or GOOGLE_API_KEY environment variable.\nFor more details see https://firebase.google.com/docs/genkit/plugins/google-genai");
    }
    const apiModelName = name.startsWith("googleai/") ? name.substring("googleai/".length) : name;
    const model = SUPPORTED_GEMINI_MODELS[name] ?? (0, import_model.modelRef)({
        name: `googleai/${apiModelName}`,
        info: {
            label: `Google AI - ${apiModelName}`,
            supports: {
                multiturn: true,
                media: true,
                tools: true,
                systemRole: true,
                output: [
                    "text",
                    "json"
                ]
            },
            ...info
        },
        configSchema: GeminiConfigSchema
    });
    const middleware = [];
    if (SUPPORTED_V1_MODELS[name]) {
        middleware.push((0, import_middleware.simulateSystemPrompt)());
    }
    if (model.info?.supports?.media) {
        middleware.push((0, import_middleware.downloadRequestMedia)({
            maxBytes: 1024 * 1024 * 10,
            // don't downlaod files that have been uploaded using the Files API
            filter: (part)=>!part.media.url.startsWith("https://generativelanguage.googleapis.com/")
        }));
    }
    return ai.defineModel({
        name: model.name,
        ...model.info,
        configSchema: model.configSchema,
        use: middleware
    }, async (request, sendChunk)=>{
        const options = {
            apiClient: import_genkit.GENKIT_CLIENT_HEADER
        };
        if (apiVersion) {
            options.apiVersion = apiVersion;
        }
        if (apiVersion) {
            options.baseUrl = baseUrl;
        }
        const requestConfig = {
            ...defaultConfig,
            ...request.config
        };
        const messages = [
            ...request.messages
        ];
        if (messages.length === 0) throw new Error("No messages provided.");
        let systemInstruction = void 0;
        if (SUPPORTED_V15_MODELS[name]) {
            const systemMessage = messages.find((m)=>m.role === "system");
            if (systemMessage) {
                messages.splice(messages.indexOf(systemMessage), 1);
                systemInstruction = toGeminiSystemInstruction(systemMessage);
            }
        }
        const tools = [];
        if (request.tools?.length) {
            tools.push({
                functionDeclarations: request.tools.map(toGeminiTool)
            });
        }
        if (requestConfig.codeExecution) {
            tools.push({
                codeExecution: request.config.codeExecution === true ? {} : request.config.codeExecution
            });
        }
        let toolConfig;
        if (requestConfig.functionCallingConfig) {
            toolConfig = {
                functionCallingConfig: {
                    allowedFunctionNames: requestConfig.functionCallingConfig.allowedFunctionNames,
                    mode: toFunctionModeEnum(requestConfig.functionCallingConfig.mode)
                }
            };
        } else if (request.toolChoice) {
            toolConfig = {
                functionCallingConfig: {
                    mode: toGeminiFunctionModeEnum(request.toolChoice)
                }
            };
        }
        const jsonMode = request.output?.format === "json" || request.output?.contentType === "application/json" && tools.length === 0;
        const generationConfig = {
            candidateCount: request.candidates || void 0,
            temperature: requestConfig.temperature,
            maxOutputTokens: requestConfig.maxOutputTokens,
            topK: requestConfig.topK,
            topP: requestConfig.topP,
            stopSequences: requestConfig.stopSequences,
            responseMimeType: jsonMode ? "application/json" : void 0
        };
        if (request.output?.constrained && jsonMode) {
            generationConfig.responseSchema = cleanSchema(request.output.schema);
        }
        const msg = toGeminiMessage(messages[messages.length - 1], model);
        const fromJSONModeScopedGeminiCandidate = (candidate)=>{
            return fromGeminiCandidate(candidate, jsonMode);
        };
        let chatRequest = {
            systemInstruction,
            generationConfig,
            tools: tools.length ? tools : void 0,
            toolConfig,
            history: messages.slice(0, -1).map((message)=>toGeminiMessage(message, model)),
            safetySettings: requestConfig.safetySettings
        };
        const modelVersion = request.config?.version || model.version || name;
        const cacheConfigDetails = (0, import_utils.extractCacheConfig)(request);
        const { chatRequest: updatedChatRequest, cache } = await (0, import_context_caching.handleCacheIfNeeded)(apiKey, request, chatRequest, modelVersion, cacheConfigDetails);
        const client = new import_generative_ai.GoogleGenerativeAI(apiKey);
        let genModel;
        if (cache) {
            genModel = client.getGenerativeModelFromCachedContent(cache, {
                model: modelVersion
            }, options);
        } else {
            genModel = client.getGenerativeModel({
                model: modelVersion
            }, options);
        }
        if (sendChunk) {
            const result = await genModel.startChat(updatedChatRequest).sendMessageStream(msg.parts, options);
            for await (const item of result.stream){
                item.candidates?.forEach((candidate)=>{
                    const c = fromJSONModeScopedGeminiCandidate(candidate);
                    sendChunk({
                        index: c.index,
                        content: c.message.content
                    });
                });
            }
            const response = await result.response;
            const candidates = response.candidates || [];
            if (response.candidates?.["undefined"]) {
                candidates.push(response.candidates["undefined"]);
            }
            if (!candidates.length) {
                throw new import_genkit.GenkitError({
                    status: "FAILED_PRECONDITION",
                    message: "No valid candidates returned."
                });
            }
            return {
                candidates: candidates.map(fromJSONModeScopedGeminiCandidate) || [],
                custom: response
            };
        } else {
            const result = await genModel.startChat(updatedChatRequest).sendMessage(msg.parts, options);
            if (!result.response.candidates?.length) throw new Error("No valid candidates returned.");
            const responseCandidates = result.response.candidates.map(fromJSONModeScopedGeminiCandidate) || [];
            return {
                candidates: responseCandidates,
                custom: result.response,
                usage: {
                    ...(0, import_model.getBasicUsageStats)(request.messages, responseCandidates),
                    inputTokens: result.response.usageMetadata?.promptTokenCount,
                    outputTokens: result.response.usageMetadata?.candidatesTokenCount,
                    totalTokens: result.response.usageMetadata?.totalTokenCount
                }
            };
        }
    });
}
function toFunctionModeEnum(configEnum) {
    if (configEnum === void 0) {
        return void 0;
    }
    switch(configEnum){
        case "MODE_UNSPECIFIED":
            {
                return import_generative_ai.FunctionCallingMode.MODE_UNSPECIFIED;
            }
        case "ANY":
            {
                return import_generative_ai.FunctionCallingMode.ANY;
            }
        case "AUTO":
            {
                return import_generative_ai.FunctionCallingMode.AUTO;
            }
        case "NONE":
            {
                return import_generative_ai.FunctionCallingMode.NONE;
            }
        default:
            throw new Error(`unsupported function calling mode: ${configEnum}`);
    }
}
function toGeminiFunctionModeEnum(genkitMode) {
    if (genkitMode === void 0) {
        return void 0;
    }
    switch(genkitMode){
        case "required":
            {
                return import_generative_ai.FunctionCallingMode.ANY;
            }
        case "auto":
            {
                return import_generative_ai.FunctionCallingMode.AUTO;
            }
        case "none":
            {
                return import_generative_ai.FunctionCallingMode.NONE;
            }
        default:
            throw new Error(`unsupported function calling mode: ${genkitMode}`);
    }
}
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
    GENERIC_GEMINI_MODEL,
    GeminiConfigSchema,
    SUPPORTED_GEMINI_MODELS,
    SUPPORTED_V15_MODELS,
    SUPPORTED_V1_MODELS,
    cleanSchema,
    defineGoogleAIModel,
    fromGeminiCandidate,
    gemini,
    gemini10Pro,
    gemini15Flash,
    gemini15Flash8b,
    gemini15Pro,
    gemini20Flash,
    toGeminiMessage,
    toGeminiSystemInstruction
}); //# sourceMappingURL=gemini.js.map
}}),
"[project]/node_modules/@genkit-ai/googleai/lib/index.mjs [app-rsc] (ecmascript) <locals>": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "default": (()=>src_default),
    "googleAI": (()=>googleAI)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$genkit$2f$lib$2f$plugin$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/genkit/lib/plugin.mjs [app-rsc] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$genkit$2d$ai$2f$googleai$2f$lib$2f$embedder$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@genkit-ai/googleai/lib/embedder.js [app-rsc] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$genkit$2d$ai$2f$googleai$2f$lib$2f$gemini$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@genkit-ai/googleai/lib/gemini.js [app-rsc] (ecmascript)");
;
;
;
function googleAI(options) {
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$genkit$2f$lib$2f$plugin$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["genkitPlugin"])("googleai", async (ai)=>{
        let apiVersions = [
            "v1"
        ];
        if (options?.apiVersion) {
            if (Array.isArray(options?.apiVersion)) {
                apiVersions = options?.apiVersion;
            } else {
                apiVersions = [
                    options?.apiVersion
                ];
            }
        }
        if (apiVersions.includes("v1beta")) {
            Object.keys(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$genkit$2d$ai$2f$googleai$2f$lib$2f$gemini$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["SUPPORTED_V15_MODELS"]).forEach((name)=>(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$genkit$2d$ai$2f$googleai$2f$lib$2f$gemini$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["defineGoogleAIModel"])(ai, name, options?.apiKey, "v1beta", options?.baseUrl));
        }
        if (apiVersions.includes("v1")) {
            Object.keys(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$genkit$2d$ai$2f$googleai$2f$lib$2f$gemini$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["SUPPORTED_V1_MODELS"]).forEach((name)=>(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$genkit$2d$ai$2f$googleai$2f$lib$2f$gemini$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["defineGoogleAIModel"])(ai, name, options?.apiKey, void 0, options?.baseUrl));
            Object.keys(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$genkit$2d$ai$2f$googleai$2f$lib$2f$gemini$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["SUPPORTED_V15_MODELS"]).forEach((name)=>(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$genkit$2d$ai$2f$googleai$2f$lib$2f$gemini$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["defineGoogleAIModel"])(ai, name, options?.apiKey, void 0, options?.baseUrl));
            Object.keys(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$genkit$2d$ai$2f$googleai$2f$lib$2f$embedder$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["SUPPORTED_MODELS"]).forEach((name)=>(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$genkit$2d$ai$2f$googleai$2f$lib$2f$embedder$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["defineGoogleAIEmbedder"])(ai, name, {
                    apiKey: options?.apiKey
                }));
        }
        if (options?.models) {
            for (const modelOrRef of options?.models){
                const modelName = typeof modelOrRef === "string" ? modelOrRef : // strip out the `googleai/` prefix
                modelOrRef.name.split("/")[1];
                const modelRef = typeof modelOrRef === "string" ? (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$genkit$2d$ai$2f$googleai$2f$lib$2f$gemini$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["gemini"])(modelOrRef) : modelOrRef;
                (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$genkit$2d$ai$2f$googleai$2f$lib$2f$gemini$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["defineGoogleAIModel"])(ai, modelName, options?.apiKey, void 0, options?.baseUrl, {
                    ...modelRef.info,
                    label: `Google AI - ${modelName}`
                });
            }
        }
    });
}
var src_default = googleAI;
;
 //# sourceMappingURL=index.mjs.map
}}),
"[project]/node_modules/@genkit-ai/googleai/lib/index.mjs [app-rsc] (ecmascript) <module evaluation>": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$genkit$2f$lib$2f$plugin$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/genkit/lib/plugin.mjs [app-rsc] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$genkit$2d$ai$2f$googleai$2f$lib$2f$embedder$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@genkit-ai/googleai/lib/embedder.js [app-rsc] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$genkit$2d$ai$2f$googleai$2f$lib$2f$gemini$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@genkit-ai/googleai/lib/gemini.js [app-rsc] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$genkit$2d$ai$2f$googleai$2f$lib$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/@genkit-ai/googleai/lib/index.mjs [app-rsc] (ecmascript) <locals>");
}}),

};

//# sourceMappingURL=node_modules_%40genkit-ai_d3f6bee1._.js.map